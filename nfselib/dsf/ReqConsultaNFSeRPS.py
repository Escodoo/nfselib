#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Nov 27 15:47:42 2019 by generateDS.py version 2.29.2.
# Python 3.7.4 (default, Oct  4 2019, 06:57:26)  [GCC 9.2.0]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('--use-getter-setter', 'none')
#   ('-f', '')
#   ('-o', '/home/mileo/Projects/oca10/src/nfselib/nfselib/dsf/ReqConsultaNFSeRPS.py')
#
# Command line arguments:
#   -
#
# Command line:
#   /home/mileo/Projects/rvaly/generateds/generateDS.py --no-namespace-defs --use-getter-setter="none" -f -o "/home/mileo/Projects/oca10/src/nfselib/nfselib/dsf/ReqConsultaNFSeRPS.py" -
#
# Current working directory (os.getcwd()):
#   dsf
#

from __future__ import unicode_literals
import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from builtins import str
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2 and not isinstance(instring, unicode):
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
                 optional=0, child_attrs=None, choice=None,
                 documentation=""):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
        self.documentation = documentation
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional
    def get_documentation(self): return self.documentation


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ReqConsultaNFSeRPS(GeneratedsSuper):
    """Schema utilizado para  Consulta de NFSe."""
    subclass = None
    superclass = None
    def __init__(self, Cabecalho=None, Lote=None, Signature=None):
        self.original_tagname_ = None
        self.Cabecalho = Cabecalho
        self.Lote = Lote
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReqConsultaNFSeRPS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReqConsultaNFSeRPS.subclass:
            return ReqConsultaNFSeRPS.subclass(*args_, **kwargs_)
        else:
            return ReqConsultaNFSeRPS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Cabecalho is not None or
            self.Lote is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='ReqConsultaNFSeRPS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReqConsultaNFSeRPS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReqConsultaNFSeRPS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='ReqConsultaNFSeRPS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='ReqConsultaNFSeRPS'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='ReqConsultaNFSeRPS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cabecalho is not None:
            self.Cabecalho.export(outfile, level, namespace_, name_='Cabecalho', pretty_print=pretty_print)
        if self.Lote is not None:
            self.Lote.export(outfile, level, namespace_, name_='Lote', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespace_='ds:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cabecalho':
            obj_ = CabecalhoType.factory()
            obj_.build(child_)
            self.Cabecalho = obj_
            obj_.original_tagname_ = 'Cabecalho'
        elif nodeName_ == 'Lote':
            obj_ = tpLoteConsultaNFSe.factory()
            obj_.build(child_)
            self.Lote = obj_
            obj_.original_tagname_ = 'Lote'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class ReqConsultaNFSeRPS


class CabecalhoType(GeneratedsSuper):
    """Cabeçalho do pedido."""
    subclass = None
    superclass = None
    def __init__(self, CodCidade=None, CPFCNPJRemetente=None, transacao=True, Versao=None):
        self.original_tagname_ = None
        self.CodCidade = CodCidade
        self.validate_tpCodCidade(self.CodCidade)
        self.CPFCNPJRemetente = CPFCNPJRemetente
        self.validate_tpCPFCNPJ(self.CPFCNPJRemetente)
        self.transacao = transacao
        self.Versao = Versao
        self.validate_tpVersao(self.Versao)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CabecalhoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CabecalhoType.subclass:
            return CabecalhoType.subclass(*args_, **kwargs_)
        else:
            return CabecalhoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpCodCidade(self, value):
        # Validate type tpCodCidade, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpCodCidade' % {"value" : value} )
    def validate_tpCPFCNPJ(self, value):
        # Validate type tpCPFCNPJ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCPFCNPJ_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCPFCNPJ_patterns_, ))
    validate_tpCPFCNPJ_patterns_ = [['^[0-9]{11}$|^[0-9]{14}$']]
    def validate_tpVersao(self, value):
        # Validate type tpVersao, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpVersao_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpVersao_patterns_, ))
    validate_tpVersao_patterns_ = [['^[0-9]{1,3}$']]
    def hasContent_(self):
        if (
            self.CodCidade is not None or
            self.CPFCNPJRemetente is not None or
            not self.transacao or
            self.Versao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='CabecalhoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CabecalhoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CabecalhoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='CabecalhoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='CabecalhoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='CabecalhoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CodCidade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CodCidade>%s</ns1:CodCidade>%s' % (self.gds_format_integer(self.CodCidade, input_name='CodCidade'), eol_))
        if self.CPFCNPJRemetente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CPFCNPJRemetente>%s</ns1:CPFCNPJRemetente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPFCNPJRemetente), input_name='CPFCNPJRemetente')), eol_))
        if self.transacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:transacao>%s</ns1:transacao>%s' % (self.gds_format_boolean(self.transacao, input_name='transacao'), eol_))
        if self.Versao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Versao>%s</ns1:Versao>%s' % (self.gds_format_integer(self.Versao, input_name='Versao'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CodCidade':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CodCidade')
            self.CodCidade = ival_
            # validate type tpCodCidade
            self.validate_tpCodCidade(self.CodCidade)
        elif nodeName_ == 'CPFCNPJRemetente':
            CPFCNPJRemetente_ = child_.text
            CPFCNPJRemetente_ = self.gds_validate_string(CPFCNPJRemetente_, node, 'CPFCNPJRemetente')
            self.CPFCNPJRemetente = CPFCNPJRemetente_
            # validate type tpCPFCNPJ
            self.validate_tpCPFCNPJ(self.CPFCNPJRemetente)
        elif nodeName_ == 'transacao':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'transacao')
            self.transacao = ival_
        elif nodeName_ == 'Versao':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Versao')
            self.Versao = ival_
            # validate type tpVersao
            self.validate_tpVersao(self.Versao)
# end class CabecalhoType


class tpBairroCompleto(GeneratedsSuper):
    """Informações do Bairro com o seu Tipo."""
    subclass = None
    superclass = None
    def __init__(self, TipoBairro=None, NomeBairro=None):
        self.original_tagname_ = None
        self.TipoBairro = TipoBairro
        self.validate_tpTipoBairro(self.TipoBairro)
        self.NomeBairro = NomeBairro
        self.validate_tpBairro(self.NomeBairro)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpBairroCompleto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpBairroCompleto.subclass:
            return tpBairroCompleto.subclass(*args_, **kwargs_)
        else:
            return tpBairroCompleto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpTipoBairro(self, value):
        # Validate type tpTipoBairro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoBairro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoBairro' % {"value" : value.encode("utf-8")} )
    def validate_tpBairro(self, value):
        # Validate type tpBairro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TipoBairro is not None or
            self.NomeBairro is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpBairroCompleto', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpBairroCompleto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpBairroCompleto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpBairroCompleto', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpBairroCompleto'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpBairroCompleto', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoBairro>%s</ns1:TipoBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoBairro), input_name='TipoBairro')), eol_))
        if self.NomeBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NomeBairro>%s</ns1:NomeBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NomeBairro), input_name='NomeBairro')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoBairro':
            TipoBairro_ = child_.text
            TipoBairro_ = self.gds_validate_string(TipoBairro_, node, 'TipoBairro')
            self.TipoBairro = TipoBairro_
            # validate type tpTipoBairro
            self.validate_tpTipoBairro(self.TipoBairro)
        elif nodeName_ == 'NomeBairro':
            NomeBairro_ = child_.text
            NomeBairro_ = self.gds_validate_string(NomeBairro_, node, 'NomeBairro')
            self.NomeBairro = NomeBairro_
            # validate type tpBairro
            self.validate_tpBairro(self.NomeBairro)
# end class tpBairroCompleto


class tpEvento(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Codigo=None, Descricao=None, ChaveRPS=None, ChaveNFe=None):
        self.original_tagname_ = None
        self.Codigo = Codigo
        self.validate_tpCodigoEvento(self.Codigo)
        self.Descricao = Descricao
        self.validate_tpDescricaoEvento(self.Descricao)
        self.ChaveRPS = ChaveRPS
        self.ChaveNFe = ChaveNFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpEvento)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpEvento.subclass:
            return tpEvento.subclass(*args_, **kwargs_)
        else:
            return tpEvento(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpCodigoEvento(self, value):
        # Validate type tpCodigoEvento, a restriction on xs:short.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCodigoEvento_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCodigoEvento_patterns_, ))
    validate_tpCodigoEvento_patterns_ = [['^[0-9]{3,4}$']]
    def validate_tpDescricaoEvento(self, value):
        # Validate type tpDescricaoEvento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 300:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDescricaoEvento' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpDescricaoEvento' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Codigo is not None or
            self.Descricao is not None or
            self.ChaveRPS is not None or
            self.ChaveNFe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpEvento', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpEvento')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpEvento')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpEvento', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpEvento'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpEvento', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Codigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Codigo>%s</ns1:Codigo>%s' % (self.gds_format_integer(self.Codigo, input_name='Codigo'), eol_))
        if self.Descricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Descricao>%s</ns1:Descricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Descricao), input_name='Descricao')), eol_))
        if self.ChaveRPS is not None:
            self.ChaveRPS.export(outfile, level, namespace_, name_='ChaveRPS', pretty_print=pretty_print)
        if self.ChaveNFe is not None:
            self.ChaveNFe.export(outfile, level, namespace_, name_='ChaveNFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Codigo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Codigo')
            self.Codigo = ival_
            # validate type tpCodigoEvento
            self.validate_tpCodigoEvento(self.Codigo)
        elif nodeName_ == 'Descricao':
            Descricao_ = child_.text
            Descricao_ = self.gds_validate_string(Descricao_, node, 'Descricao')
            self.Descricao = Descricao_
            # validate type tpDescricaoEvento
            self.validate_tpDescricaoEvento(self.Descricao)
        elif nodeName_ == 'ChaveRPS':
            obj_ = tpChaveRPS.factory()
            obj_.build(child_)
            self.ChaveRPS = obj_
            obj_.original_tagname_ = 'ChaveRPS'
        elif nodeName_ == 'ChaveNFe':
            obj_ = tpChaveNFe.factory()
            obj_.build(child_)
            self.ChaveNFe = obj_
            obj_.original_tagname_ = 'ChaveNFe'
# end class tpEvento


class tpCPFCNPJ2(GeneratedsSuper):
    """Tipo que representa um CPF/CNPJ."""
    subclass = None
    superclass = None
    def __init__(self, CPF=None, CNPJ=None):
        self.original_tagname_ = None
        self.CPF = CPF
        self.validate_tpCPF(self.CPF)
        self.CNPJ = CNPJ
        self.validate_tpCNPJ(self.CNPJ)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpCPFCNPJ2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpCPFCNPJ2.subclass:
            return tpCPFCNPJ2.subclass(*args_, **kwargs_)
        else:
            return tpCPFCNPJ2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpCPF(self, value):
        # Validate type tpCPF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCPF_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCPF_patterns_, ))
    validate_tpCPF_patterns_ = [['^[0-9]{0}$|^[0-9]{11}$']]
    def validate_tpCNPJ(self, value):
        # Validate type tpCNPJ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCNPJ_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCNPJ_patterns_, ))
    validate_tpCNPJ_patterns_ = [['^[0-9]{14}$']]
    def hasContent_(self):
        if (
            self.CPF is not None or
            self.CNPJ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpCPFCNPJ2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpCPFCNPJ2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpCPFCNPJ2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpCPFCNPJ2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpCPFCNPJ2'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpCPFCNPJ2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CPF>%s</ns1:CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CNPJ>%s</ns1:CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type tpCPF
            self.validate_tpCPF(self.CPF)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type tpCNPJ
            self.validate_tpCNPJ(self.CNPJ)
# end class tpCPFCNPJ2


class tpConsultaNFSe(GeneratedsSuper):
    """NFSe de retorno de consulta."""
    subclass = None
    superclass = None
    def __init__(self, InscricaoPrestador=None, NumeroNFe=None, CodigoVerificacao=None, SerieRPS=None, NumeroRPS=None, DataEmissaoRPS=None, RazaoSocialPrestador=None, TipoRecolhimento=None, ValorDeduzir=None, ValorTotal=None, Aliquota=None):
        self.original_tagname_ = None
        self.InscricaoPrestador = InscricaoPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        self.NumeroNFe = NumeroNFe
        self.validate_tpNumero(self.NumeroNFe)
        self.CodigoVerificacao = CodigoVerificacao
        self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
        self.SerieRPS = SerieRPS
        self.validate_tpSerieRPS(self.SerieRPS)
        self.NumeroRPS = NumeroRPS
        self.validate_tpNumero(self.NumeroRPS)
        if isinstance(DataEmissaoRPS, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataEmissaoRPS, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DataEmissaoRPS
        self.DataEmissaoRPS = initvalue_
        self.RazaoSocialPrestador = RazaoSocialPrestador
        self.validate_tpRazaoSocial(self.RazaoSocialPrestador)
        self.TipoRecolhimento = TipoRecolhimento
        self.validate_tpTipoRecolhimento(self.TipoRecolhimento)
        self.ValorDeduzir = ValorDeduzir
        self.validate_tpValor(self.ValorDeduzir)
        self.ValorTotal = ValorTotal
        self.validate_tpValor(self.ValorTotal)
        self.Aliquota = Aliquota
        self.validate_tpAliquota(self.Aliquota)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpConsultaNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpConsultaNFSe.subclass:
            return tpConsultaNFSe.subclass(*args_, **kwargs_)
        else:
            return tpConsultaNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpCodigoVerificacao(self, value):
        # Validate type tpCodigoVerificacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
    def validate_tpSerieRPS(self, value):
        # Validate type tpSerieRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpSerieRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpDataHora(self, value):
        # Validate type tpDataHora, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpRazaoSocial(self, value):
        # Validate type tpRazaoSocial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoRecolhimento(self, value):
        # Validate type tpTipoRecolhimento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'R']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTipoRecolhimento' % {"value" : value.encode("utf-8")} )
    def validate_tpValor(self, value):
        # Validate type tpValor, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpValor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpValor_patterns_, ))
    validate_tpValor_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{0,2})?$']]
    def validate_tpAliquota(self, value):
        # Validate type tpAliquota, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpAliquota' % {"value" : value} )
            if len(str(value)) >= 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpAliquota' % {"value" : value} )
    def hasContent_(self):
        if (
            self.InscricaoPrestador is not None or
            self.NumeroNFe is not None or
            self.CodigoVerificacao is not None or
            self.SerieRPS is not None or
            self.NumeroRPS is not None or
            self.DataEmissaoRPS is not None or
            self.RazaoSocialPrestador is not None or
            self.TipoRecolhimento is not None or
            self.ValorDeduzir is not None or
            self.ValorTotal is not None or
            self.Aliquota is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpConsultaNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpConsultaNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpConsultaNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpConsultaNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpConsultaNFSe'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpConsultaNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoPrestador>%s</ns1:InscricaoPrestador>%s' % (self.gds_format_integer(self.InscricaoPrestador, input_name='InscricaoPrestador'), eol_))
        if self.NumeroNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroNFe>%s</ns1:NumeroNFe>%s' % (self.gds_format_integer(self.NumeroNFe, input_name='NumeroNFe'), eol_))
        if self.CodigoVerificacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CodigoVerificacao>%s</ns1:CodigoVerificacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CodigoVerificacao), input_name='CodigoVerificacao')), eol_))
        if self.SerieRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SerieRPS>%s</ns1:SerieRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SerieRPS), input_name='SerieRPS')), eol_))
        if self.NumeroRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroRPS>%s</ns1:NumeroRPS>%s' % (self.gds_format_integer(self.NumeroRPS, input_name='NumeroRPS'), eol_))
        if self.DataEmissaoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DataEmissaoRPS>%s</ns1:DataEmissaoRPS>%s' % (self.gds_format_datetime(self.DataEmissaoRPS, input_name='DataEmissaoRPS'), eol_))
        if self.RazaoSocialPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:RazaoSocialPrestador>%s</ns1:RazaoSocialPrestador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RazaoSocialPrestador), input_name='RazaoSocialPrestador')), eol_))
        if self.TipoRecolhimento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoRecolhimento>%s</ns1:TipoRecolhimento>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoRecolhimento), input_name='TipoRecolhimento')), eol_))
        if self.ValorDeduzir is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorDeduzir>%s</ns1:ValorDeduzir>%s' % (self.gds_format_float(self.ValorDeduzir, input_name='ValorDeduzir'), eol_))
        if self.ValorTotal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorTotal>%s</ns1:ValorTotal>%s' % (self.gds_format_float(self.ValorTotal, input_name='ValorTotal'), eol_))
        if self.Aliquota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Aliquota>%s</ns1:Aliquota>%s' % (self.gds_format_float(self.Aliquota, input_name='Aliquota'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoPrestador')
            self.InscricaoPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        elif nodeName_ == 'NumeroNFe':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNFe')
            self.NumeroNFe = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroNFe)
        elif nodeName_ == 'CodigoVerificacao':
            CodigoVerificacao_ = child_.text
            CodigoVerificacao_ = self.gds_validate_string(CodigoVerificacao_, node, 'CodigoVerificacao')
            self.CodigoVerificacao = CodigoVerificacao_
            # validate type tpCodigoVerificacao
            self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
        elif nodeName_ == 'SerieRPS':
            SerieRPS_ = child_.text
            SerieRPS_ = self.gds_validate_string(SerieRPS_, node, 'SerieRPS')
            self.SerieRPS = SerieRPS_
            # validate type tpSerieRPS
            self.validate_tpSerieRPS(self.SerieRPS)
        elif nodeName_ == 'NumeroRPS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroRPS')
            self.NumeroRPS = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroRPS)
        elif nodeName_ == 'DataEmissaoRPS':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DataEmissaoRPS = dval_
            # validate type tpDataHora
            self.validate_tpDataHora(self.DataEmissaoRPS)
        elif nodeName_ == 'RazaoSocialPrestador':
            RazaoSocialPrestador_ = child_.text
            RazaoSocialPrestador_ = self.gds_validate_string(RazaoSocialPrestador_, node, 'RazaoSocialPrestador')
            self.RazaoSocialPrestador = RazaoSocialPrestador_
            # validate type tpRazaoSocial
            self.validate_tpRazaoSocial(self.RazaoSocialPrestador)
        elif nodeName_ == 'TipoRecolhimento':
            TipoRecolhimento_ = child_.text
            TipoRecolhimento_ = self.gds_validate_string(TipoRecolhimento_, node, 'TipoRecolhimento')
            self.TipoRecolhimento = TipoRecolhimento_
            # validate type tpTipoRecolhimento
            self.validate_tpTipoRecolhimento(self.TipoRecolhimento)
        elif nodeName_ == 'ValorDeduzir':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorDeduzir')
            self.ValorDeduzir = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorDeduzir)
        elif nodeName_ == 'ValorTotal':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorTotal')
            self.ValorTotal = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorTotal)
        elif nodeName_ == 'Aliquota':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Aliquota')
            self.Aliquota = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.Aliquota)
# end class tpConsultaNFSe


class tpChaveNFeRPS(GeneratedsSuper):
    """Tipo que representa a chave de uma NFSe e a Chave do RPS que a mesma
    substitui."""
    subclass = None
    superclass = None
    def __init__(self, ChaveNFe=None, ChaveRPS=None):
        self.original_tagname_ = None
        self.ChaveNFe = ChaveNFe
        self.ChaveRPS = ChaveRPS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpChaveNFeRPS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpChaveNFeRPS.subclass:
            return tpChaveNFeRPS.subclass(*args_, **kwargs_)
        else:
            return tpChaveNFeRPS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ChaveNFe is not None or
            self.ChaveRPS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpChaveNFeRPS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpChaveNFeRPS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpChaveNFeRPS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpChaveNFeRPS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpChaveNFeRPS'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpChaveNFeRPS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChaveNFe is not None:
            self.ChaveNFe.export(outfile, level, namespace_, name_='ChaveNFe', pretty_print=pretty_print)
        if self.ChaveRPS is not None:
            self.ChaveRPS.export(outfile, level, namespace_, name_='ChaveRPS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChaveNFe':
            obj_ = tpChaveNFe.factory()
            obj_.build(child_)
            self.ChaveNFe = obj_
            obj_.original_tagname_ = 'ChaveNFe'
        elif nodeName_ == 'ChaveRPS':
            obj_ = tpChaveRPS.factory()
            obj_.build(child_)
            self.ChaveRPS = obj_
            obj_.original_tagname_ = 'ChaveRPS'
# end class tpChaveNFeRPS


class tpChaveNFe(GeneratedsSuper):
    """Chave de identificação da NF-e."""
    subclass = None
    superclass = None
    def __init__(self, InscricaoPrestador=None, NumeroNFe=None, CodigoVerificacao=None, RazaoSocialPrestador=None):
        self.original_tagname_ = None
        self.InscricaoPrestador = InscricaoPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        self.NumeroNFe = NumeroNFe
        self.validate_tpNumero(self.NumeroNFe)
        self.CodigoVerificacao = CodigoVerificacao
        self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
        self.RazaoSocialPrestador = RazaoSocialPrestador
        self.validate_tpRazaoSocial(self.RazaoSocialPrestador)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpChaveNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpChaveNFe.subclass:
            return tpChaveNFe.subclass(*args_, **kwargs_)
        else:
            return tpChaveNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpCodigoVerificacao(self, value):
        # Validate type tpCodigoVerificacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
    def validate_tpRazaoSocial(self, value):
        # Validate type tpRazaoSocial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InscricaoPrestador is not None or
            self.NumeroNFe is not None or
            self.CodigoVerificacao is not None or
            self.RazaoSocialPrestador is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpChaveNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpChaveNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpChaveNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpChaveNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpChaveNFe'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpChaveNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoPrestador>%s</ns1:InscricaoPrestador>%s' % (self.gds_format_integer(self.InscricaoPrestador, input_name='InscricaoPrestador'), eol_))
        if self.NumeroNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroNFe>%s</ns1:NumeroNFe>%s' % (self.gds_format_integer(self.NumeroNFe, input_name='NumeroNFe'), eol_))
        if self.CodigoVerificacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CodigoVerificacao>%s</ns1:CodigoVerificacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CodigoVerificacao), input_name='CodigoVerificacao')), eol_))
        if self.RazaoSocialPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:RazaoSocialPrestador>%s</ns1:RazaoSocialPrestador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RazaoSocialPrestador), input_name='RazaoSocialPrestador')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoPrestador')
            self.InscricaoPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        elif nodeName_ == 'NumeroNFe':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNFe')
            self.NumeroNFe = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroNFe)
        elif nodeName_ == 'CodigoVerificacao':
            CodigoVerificacao_ = child_.text
            CodigoVerificacao_ = self.gds_validate_string(CodigoVerificacao_, node, 'CodigoVerificacao')
            self.CodigoVerificacao = CodigoVerificacao_
            # validate type tpCodigoVerificacao
            self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
        elif nodeName_ == 'RazaoSocialPrestador':
            RazaoSocialPrestador_ = child_.text
            RazaoSocialPrestador_ = self.gds_validate_string(RazaoSocialPrestador_, node, 'RazaoSocialPrestador')
            self.RazaoSocialPrestador = RazaoSocialPrestador_
            # validate type tpRazaoSocial
            self.validate_tpRazaoSocial(self.RazaoSocialPrestador)
# end class tpChaveNFe


class tpChaveRPS(GeneratedsSuper):
    """Tipo que define a chave identificadora de um RPS."""
    subclass = None
    superclass = None
    def __init__(self, InscricaoPrestador=None, SerieRPS=None, NumeroRPS=None, DataEmissaoRPS=None, RazaoSocialPrestador=None):
        self.original_tagname_ = None
        self.InscricaoPrestador = InscricaoPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        self.SerieRPS = SerieRPS
        self.validate_tpSerieRPS(self.SerieRPS)
        self.NumeroRPS = NumeroRPS
        self.validate_tpNumero(self.NumeroRPS)
        if isinstance(DataEmissaoRPS, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataEmissaoRPS, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DataEmissaoRPS
        self.DataEmissaoRPS = initvalue_
        self.RazaoSocialPrestador = RazaoSocialPrestador
        self.validate_tpRazaoSocial(self.RazaoSocialPrestador)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpChaveRPS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpChaveRPS.subclass:
            return tpChaveRPS.subclass(*args_, **kwargs_)
        else:
            return tpChaveRPS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpSerieRPS(self, value):
        # Validate type tpSerieRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpSerieRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpRazaoSocial(self, value):
        # Validate type tpRazaoSocial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InscricaoPrestador is not None or
            self.SerieRPS is not None or
            self.NumeroRPS is not None or
            self.DataEmissaoRPS is not None or
            self.RazaoSocialPrestador is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpChaveRPS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpChaveRPS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpChaveRPS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpChaveRPS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpChaveRPS'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpChaveRPS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoPrestador>%s</ns1:InscricaoPrestador>%s' % (self.gds_format_integer(self.InscricaoPrestador, input_name='InscricaoPrestador'), eol_))
        if self.SerieRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SerieRPS>%s</ns1:SerieRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SerieRPS), input_name='SerieRPS')), eol_))
        if self.NumeroRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroRPS>%s</ns1:NumeroRPS>%s' % (self.gds_format_integer(self.NumeroRPS, input_name='NumeroRPS'), eol_))
        if self.DataEmissaoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DataEmissaoRPS>%s</ns1:DataEmissaoRPS>%s' % (self.gds_format_datetime(self.DataEmissaoRPS, input_name='DataEmissaoRPS'), eol_))
        if self.RazaoSocialPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:RazaoSocialPrestador>%s</ns1:RazaoSocialPrestador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RazaoSocialPrestador), input_name='RazaoSocialPrestador')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoPrestador')
            self.InscricaoPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        elif nodeName_ == 'SerieRPS':
            SerieRPS_ = child_.text
            SerieRPS_ = self.gds_validate_string(SerieRPS_, node, 'SerieRPS')
            self.SerieRPS = SerieRPS_
            # validate type tpSerieRPS
            self.validate_tpSerieRPS(self.SerieRPS)
        elif nodeName_ == 'NumeroRPS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroRPS')
            self.NumeroRPS = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroRPS)
        elif nodeName_ == 'DataEmissaoRPS':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DataEmissaoRPS = dval_
        elif nodeName_ == 'RazaoSocialPrestador':
            RazaoSocialPrestador_ = child_.text
            RazaoSocialPrestador_ = self.gds_validate_string(RazaoSocialPrestador_, node, 'RazaoSocialPrestador')
            self.RazaoSocialPrestador = RazaoSocialPrestador_
            # validate type tpRazaoSocial
            self.validate_tpRazaoSocial(self.RazaoSocialPrestador)
# end class tpChaveRPS


class tpChaveSubstituicaoNFSe(GeneratedsSuper):
    """Chave de identificação para Substituição de uma NFSe."""
    subclass = None
    superclass = None
    def __init__(self, InscricaoPrestador=None, CPFCNPJTomador=None, NumeroNFSeSubstituida=None, DataEmissaoNFSeSubstituida=None):
        self.original_tagname_ = None
        self.InscricaoPrestador = InscricaoPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        self.CPFCNPJTomador = CPFCNPJTomador
        self.validate_tpCPFCNPJ(self.CPFCNPJTomador)
        self.NumeroNFSeSubstituida = NumeroNFSeSubstituida
        self.validate_tpNumero(self.NumeroNFSeSubstituida)
        if isinstance(DataEmissaoNFSeSubstituida, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataEmissaoNFSeSubstituida, '%Y-%m-%d').date()
        else:
            initvalue_ = DataEmissaoNFSeSubstituida
        self.DataEmissaoNFSeSubstituida = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpChaveSubstituicaoNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpChaveSubstituicaoNFSe.subclass:
            return tpChaveSubstituicaoNFSe.subclass(*args_, **kwargs_)
        else:
            return tpChaveSubstituicaoNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpCPFCNPJ(self, value):
        # Validate type tpCPFCNPJ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCPFCNPJ_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCPFCNPJ_patterns_, ))
    validate_tpCPFCNPJ_patterns_ = [['^[0-9]{11}$|^[0-9]{14}$']]
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpData(self, value):
        # Validate type tpData, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.InscricaoPrestador is not None or
            self.CPFCNPJTomador is not None or
            self.NumeroNFSeSubstituida is not None or
            self.DataEmissaoNFSeSubstituida is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpChaveSubstituicaoNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpChaveSubstituicaoNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpChaveSubstituicaoNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpChaveSubstituicaoNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpChaveSubstituicaoNFSe'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpChaveSubstituicaoNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoPrestador>%s</ns1:InscricaoPrestador>%s' % (self.gds_format_integer(self.InscricaoPrestador, input_name='InscricaoPrestador'), eol_))
        if self.CPFCNPJTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CPFCNPJTomador>%s</ns1:CPFCNPJTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPFCNPJTomador), input_name='CPFCNPJTomador')), eol_))
        if self.NumeroNFSeSubstituida is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroNFSeSubstituida>%s</ns1:NumeroNFSeSubstituida>%s' % (self.gds_format_integer(self.NumeroNFSeSubstituida, input_name='NumeroNFSeSubstituida'), eol_))
        if self.DataEmissaoNFSeSubstituida is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DataEmissaoNFSeSubstituida>%s</ns1:DataEmissaoNFSeSubstituida>%s' % (self.gds_format_date(self.DataEmissaoNFSeSubstituida, input_name='DataEmissaoNFSeSubstituida'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoPrestador')
            self.InscricaoPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        elif nodeName_ == 'CPFCNPJTomador':
            CPFCNPJTomador_ = child_.text
            CPFCNPJTomador_ = self.gds_validate_string(CPFCNPJTomador_, node, 'CPFCNPJTomador')
            self.CPFCNPJTomador = CPFCNPJTomador_
            # validate type tpCPFCNPJ
            self.validate_tpCPFCNPJ(self.CPFCNPJTomador)
        elif nodeName_ == 'NumeroNFSeSubstituida':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNFSeSubstituida')
            self.NumeroNFSeSubstituida = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroNFSeSubstituida)
        elif nodeName_ == 'DataEmissaoNFSeSubstituida':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DataEmissaoNFSeSubstituida = dval_
            # validate type tpData
            self.validate_tpData(self.DataEmissaoNFSeSubstituida)
# end class tpChaveSubstituicaoNFSe


class tpDeducoes(GeneratedsSuper):
    """Tipo deduções de nota fiscal."""
    subclass = None
    superclass = None
    def __init__(self, DeducaoPor=None, TipoDeducao=None, CPFCNPJReferencia=None, NumeroNFReferencia=None, ValorTotalReferencia=None, PercentualDeduzir=None, ValorDeduzir=None):
        self.original_tagname_ = None
        self.DeducaoPor = DeducaoPor
        self.validate_tpDeducaoPor(self.DeducaoPor)
        self.TipoDeducao = TipoDeducao
        self.validate_tpTipoDeducao(self.TipoDeducao)
        self.CPFCNPJReferencia = CPFCNPJReferencia
        self.validate_tpCPFCNPJnulo(self.CPFCNPJReferencia)
        self.NumeroNFReferencia = NumeroNFReferencia
        self.validate_tpNumeroNFReferencia(self.NumeroNFReferencia)
        self.ValorTotalReferencia = ValorTotalReferencia
        self.validate_tpValor(self.ValorTotalReferencia)
        self.PercentualDeduzir = PercentualDeduzir
        self.validate_tpPercentual(self.PercentualDeduzir)
        self.ValorDeduzir = ValorDeduzir
        self.validate_tpValor(self.ValorDeduzir)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpDeducoes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpDeducoes.subclass:
            return tpDeducoes.subclass(*args_, **kwargs_)
        else:
            return tpDeducoes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpDeducaoPor(self, value):
        # Validate type tpDeducaoPor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Valor', 'Percentual']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpDeducaoPor' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoDeducao(self, value):
        # Validate type tpTipoDeducao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Despesas com Materiais', 'Despesas com Subempreitada', 'Despesas com Mercadorias', 'Servicos de Veiculacao e Divulgacao', 'Servicos', 'Mapa de Const. Civil', '']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTipoDeducao' % {"value" : value.encode("utf-8")} )
    def validate_tpCPFCNPJnulo(self, value):
        # Validate type tpCPFCNPJnulo, a restriction on None.
        pass
    def validate_tpNumeroNFReferencia(self, value):
        # Validate type tpNumeroNFReferencia, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumeroNFReferencia' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumeroNFReferencia_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumeroNFReferencia_patterns_, ))
    validate_tpNumeroNFReferencia_patterns_ = [['^[0-9]{1,10}$']]
    def validate_tpValor(self, value):
        # Validate type tpValor, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpValor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpValor_patterns_, ))
    validate_tpValor_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{0,2})?$']]
    def validate_tpPercentual(self, value):
        # Validate type tpPercentual, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpPercentual' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpPercentual' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DeducaoPor is not None or
            self.TipoDeducao is not None or
            self.CPFCNPJReferencia is not None or
            self.NumeroNFReferencia is not None or
            self.ValorTotalReferencia is not None or
            self.PercentualDeduzir is not None or
            self.ValorDeduzir is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpDeducoes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpDeducoes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpDeducoes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpDeducoes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpDeducoes'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpDeducoes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DeducaoPor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DeducaoPor>%s</ns1:DeducaoPor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeducaoPor), input_name='DeducaoPor')), eol_))
        if self.TipoDeducao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoDeducao>%s</ns1:TipoDeducao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoDeducao), input_name='TipoDeducao')), eol_))
        if self.CPFCNPJReferencia is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CPFCNPJReferencia>%s</ns1:CPFCNPJReferencia>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPFCNPJReferencia), input_name='CPFCNPJReferencia')), eol_))
        if self.NumeroNFReferencia is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroNFReferencia>%s</ns1:NumeroNFReferencia>%s' % (self.gds_format_integer(self.NumeroNFReferencia, input_name='NumeroNFReferencia'), eol_))
        if self.ValorTotalReferencia is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorTotalReferencia>%s</ns1:ValorTotalReferencia>%s' % (self.gds_format_float(self.ValorTotalReferencia, input_name='ValorTotalReferencia'), eol_))
        if self.PercentualDeduzir is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:PercentualDeduzir>%s</ns1:PercentualDeduzir>%s' % (self.gds_format_float(self.PercentualDeduzir, input_name='PercentualDeduzir'), eol_))
        if self.ValorDeduzir is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorDeduzir>%s</ns1:ValorDeduzir>%s' % (self.gds_format_float(self.ValorDeduzir, input_name='ValorDeduzir'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DeducaoPor':
            DeducaoPor_ = child_.text
            DeducaoPor_ = self.gds_validate_string(DeducaoPor_, node, 'DeducaoPor')
            self.DeducaoPor = DeducaoPor_
            # validate type tpDeducaoPor
            self.validate_tpDeducaoPor(self.DeducaoPor)
        elif nodeName_ == 'TipoDeducao':
            TipoDeducao_ = child_.text
            TipoDeducao_ = self.gds_validate_string(TipoDeducao_, node, 'TipoDeducao')
            self.TipoDeducao = TipoDeducao_
            # validate type tpTipoDeducao
            self.validate_tpTipoDeducao(self.TipoDeducao)
        elif nodeName_ == 'CPFCNPJReferencia':
            CPFCNPJReferencia_ = child_.text
            CPFCNPJReferencia_ = self.gds_validate_string(CPFCNPJReferencia_, node, 'CPFCNPJReferencia')
            self.CPFCNPJReferencia = CPFCNPJReferencia_
            # validate type tpCPFCNPJnulo
            self.validate_tpCPFCNPJnulo(self.CPFCNPJReferencia)
        elif nodeName_ == 'NumeroNFReferencia':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNFReferencia')
            self.NumeroNFReferencia = ival_
            # validate type tpNumeroNFReferencia
            self.validate_tpNumeroNFReferencia(self.NumeroNFReferencia)
        elif nodeName_ == 'ValorTotalReferencia':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorTotalReferencia')
            self.ValorTotalReferencia = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorTotalReferencia)
        elif nodeName_ == 'PercentualDeduzir':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PercentualDeduzir')
            self.PercentualDeduzir = fval_
            # validate type tpPercentual
            self.validate_tpPercentual(self.PercentualDeduzir)
        elif nodeName_ == 'ValorDeduzir':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorDeduzir')
            self.ValorDeduzir = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorDeduzir)
# end class tpDeducoes


class tpNotaCancelamentoNFSe(GeneratedsSuper):
    """Tipo Detalhes do Cancelamento de NFSe."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, InscricaoMunicipalPrestador=None, NumeroNota=None, CodigoVerificacao=None, MotivoCancelamento=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.InscricaoMunicipalPrestador = InscricaoMunicipalPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        self.NumeroNota = NumeroNota
        self.validate_tpNumero(self.NumeroNota)
        self.CodigoVerificacao = CodigoVerificacao
        self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
        self.MotivoCancelamento = MotivoCancelamento
        self.validate_tpMotCancelamento(self.MotivoCancelamento)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpNotaCancelamentoNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpNotaCancelamentoNFSe.subclass:
            return tpNotaCancelamentoNFSe.subclass(*args_, **kwargs_)
        else:
            return tpNotaCancelamentoNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpCodigoVerificacao(self, value):
        # Validate type tpCodigoVerificacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
    def validate_tpMotCancelamento(self, value):
        # Validate type tpMotCancelamento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpMotCancelamento' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpMotCancelamento' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InscricaoMunicipalPrestador is not None or
            self.NumeroNota is not None or
            self.CodigoVerificacao is not None or
            self.MotivoCancelamento is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpNotaCancelamentoNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpNotaCancelamentoNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpNotaCancelamentoNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpNotaCancelamentoNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpNotaCancelamentoNFSe'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpNotaCancelamentoNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoMunicipalPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoMunicipalPrestador>%s</ns1:InscricaoMunicipalPrestador>%s' % (self.gds_format_integer(self.InscricaoMunicipalPrestador, input_name='InscricaoMunicipalPrestador'), eol_))
        if self.NumeroNota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroNota>%s</ns1:NumeroNota>%s' % (self.gds_format_integer(self.NumeroNota, input_name='NumeroNota'), eol_))
        if self.CodigoVerificacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CodigoVerificacao>%s</ns1:CodigoVerificacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CodigoVerificacao), input_name='CodigoVerificacao')), eol_))
        if self.MotivoCancelamento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:MotivoCancelamento>%s</ns1:MotivoCancelamento>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MotivoCancelamento), input_name='MotivoCancelamento')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoMunicipalPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipalPrestador')
            self.InscricaoMunicipalPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        elif nodeName_ == 'NumeroNota':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNota')
            self.NumeroNota = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroNota)
        elif nodeName_ == 'CodigoVerificacao':
            CodigoVerificacao_ = child_.text
            CodigoVerificacao_ = self.gds_validate_string(CodigoVerificacao_, node, 'CodigoVerificacao')
            self.CodigoVerificacao = CodigoVerificacao_
            # validate type tpCodigoVerificacao
            self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
        elif nodeName_ == 'MotivoCancelamento':
            MotivoCancelamento_ = child_.text
            MotivoCancelamento_ = self.gds_validate_string(MotivoCancelamento_, node, 'MotivoCancelamento')
            self.MotivoCancelamento = MotivoCancelamento_
            # validate type tpMotCancelamento
            self.validate_tpMotCancelamento(self.MotivoCancelamento)
# end class tpNotaCancelamentoNFSe


class tpDetalhesConsultaRPS(GeneratedsSuper):
    """Tipo Detalhes da Consulta de RPS."""
    subclass = None
    superclass = None
    def __init__(self, InscricaoPrestador=None, SerieRPS=None, NumeroRPS=None):
        self.original_tagname_ = None
        self.InscricaoPrestador = InscricaoPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        self.SerieRPS = SerieRPS
        self.validate_tpSerieRPS(self.SerieRPS)
        self.NumeroRPS = NumeroRPS
        self.validate_tpNumero(self.NumeroRPS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpDetalhesConsultaRPS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpDetalhesConsultaRPS.subclass:
            return tpDetalhesConsultaRPS.subclass(*args_, **kwargs_)
        else:
            return tpDetalhesConsultaRPS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpSerieRPS(self, value):
        # Validate type tpSerieRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpSerieRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def hasContent_(self):
        if (
            self.InscricaoPrestador is not None or
            self.SerieRPS is not None or
            self.NumeroRPS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpDetalhesConsultaRPS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpDetalhesConsultaRPS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpDetalhesConsultaRPS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpDetalhesConsultaRPS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpDetalhesConsultaRPS'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpDetalhesConsultaRPS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoPrestador>%s</ns1:InscricaoPrestador>%s' % (self.gds_format_integer(self.InscricaoPrestador, input_name='InscricaoPrestador'), eol_))
        if self.SerieRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SerieRPS>%s</ns1:SerieRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SerieRPS), input_name='SerieRPS')), eol_))
        if self.NumeroRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroRPS>%s</ns1:NumeroRPS>%s' % (self.gds_format_integer(self.NumeroRPS, input_name='NumeroRPS'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoPrestador')
            self.InscricaoPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        elif nodeName_ == 'SerieRPS':
            SerieRPS_ = child_.text
            SerieRPS_ = self.gds_validate_string(SerieRPS_, node, 'SerieRPS')
            self.SerieRPS = SerieRPS_
            # validate type tpSerieRPS
            self.validate_tpSerieRPS(self.SerieRPS)
        elif nodeName_ == 'NumeroRPS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroRPS')
            self.NumeroRPS = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroRPS)
# end class tpDetalhesConsultaRPS


class tpItens(GeneratedsSuper):
    """Tipo Itens de Nota Fiscal."""
    subclass = None
    superclass = None
    def __init__(self, DiscriminacaoServico=None, Quantidade=None, ValorUnitario=None, ValorTotal=None, Tributavel=None):
        self.original_tagname_ = None
        self.DiscriminacaoServico = DiscriminacaoServico
        self.validate_tpDiscriminacao(self.DiscriminacaoServico)
        self.Quantidade = Quantidade
        self.validate_tpQuantidade(self.Quantidade)
        self.ValorUnitario = ValorUnitario
        self.validate_tpValor4d(self.ValorUnitario)
        self.ValorTotal = ValorTotal
        self.validate_tpValor(self.ValorTotal)
        self.Tributavel = Tributavel
        self.validate_tpItemTributavel(self.Tributavel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpItens)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpItens.subclass:
            return tpItens.subclass(*args_, **kwargs_)
        else:
            return tpItens(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpDiscriminacao(self, value):
        # Validate type tpDiscriminacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 250:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDiscriminacao' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpDiscriminacao' % {"value" : value.encode("utf-8")} )
    def validate_tpQuantidade(self, value):
        # Validate type tpQuantidade, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpQuantidade' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpQuantidade' % {"value" : value} )
    def validate_tpValor4d(self, value):
        # Validate type tpValor4d, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor4d' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor4d' % {"value" : value} )
    def validate_tpValor(self, value):
        # Validate type tpValor, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpValor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpValor_patterns_, ))
    validate_tpValor_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{0,2})?$']]
    def validate_tpItemTributavel(self, value):
        # Validate type tpItemTributavel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpItemTributavel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DiscriminacaoServico is not None or
            self.Quantidade is not None or
            self.ValorUnitario is not None or
            self.ValorTotal is not None or
            self.Tributavel is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpItens', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpItens')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpItens')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpItens', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpItens'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpItens', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DiscriminacaoServico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DiscriminacaoServico>%s</ns1:DiscriminacaoServico>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DiscriminacaoServico), input_name='DiscriminacaoServico')), eol_))
        if self.Quantidade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Quantidade>%s</ns1:Quantidade>%s' % (self.gds_format_float(self.Quantidade, input_name='Quantidade'), eol_))
        if self.ValorUnitario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorUnitario>%s</ns1:ValorUnitario>%s' % (self.gds_format_float(self.ValorUnitario, input_name='ValorUnitario'), eol_))
        if self.ValorTotal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorTotal>%s</ns1:ValorTotal>%s' % (self.gds_format_float(self.ValorTotal, input_name='ValorTotal'), eol_))
        if self.Tributavel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Tributavel>%s</ns1:Tributavel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Tributavel), input_name='Tributavel')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DiscriminacaoServico':
            DiscriminacaoServico_ = child_.text
            DiscriminacaoServico_ = self.gds_validate_string(DiscriminacaoServico_, node, 'DiscriminacaoServico')
            self.DiscriminacaoServico = DiscriminacaoServico_
            # validate type tpDiscriminacao
            self.validate_tpDiscriminacao(self.DiscriminacaoServico)
        elif nodeName_ == 'Quantidade':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Quantidade')
            self.Quantidade = fval_
            # validate type tpQuantidade
            self.validate_tpQuantidade(self.Quantidade)
        elif nodeName_ == 'ValorUnitario':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorUnitario')
            self.ValorUnitario = fval_
            # validate type tpValor4d
            self.validate_tpValor4d(self.ValorUnitario)
        elif nodeName_ == 'ValorTotal':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorTotal')
            self.ValorTotal = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorTotal)
        elif nodeName_ == 'Tributavel':
            Tributavel_ = child_.text
            Tributavel_ = self.gds_validate_string(Tributavel_, node, 'Tributavel')
            self.Tributavel = Tributavel_
            # validate type tpItemTributavel
            self.validate_tpItemTributavel(self.Tributavel)
# end class tpItens


class tpEndereco(GeneratedsSuper):
    """Tipo Endereço."""
    subclass = None
    superclass = None
    def __init__(self, TipoLogradouro=None, Logradouro=None, NumeroEndereco=None, ComplementoEndereco=None, TipoBairro=None, Bairro=None, Cidade=None, UF=None, CEP=None):
        self.original_tagname_ = None
        self.TipoLogradouro = TipoLogradouro
        self.validate_tpTipoLogradouro(self.TipoLogradouro)
        self.Logradouro = Logradouro
        self.validate_tpLogradouro(self.Logradouro)
        self.NumeroEndereco = NumeroEndereco
        self.validate_tpNumeroEndereco(self.NumeroEndereco)
        self.ComplementoEndereco = ComplementoEndereco
        self.validate_tpComplementoEndereco(self.ComplementoEndereco)
        self.TipoBairro = TipoBairro
        self.validate_tpTipoBairro(self.TipoBairro)
        self.Bairro = Bairro
        self.validate_tpBairro(self.Bairro)
        self.Cidade = Cidade
        self.validate_tpCidade(self.Cidade)
        self.UF = UF
        self.validate_tpUF(self.UF)
        self.CEP = CEP
        self.validate_tpCEP(self.CEP)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpEndereco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpEndereco.subclass:
            return tpEndereco.subclass(*args_, **kwargs_)
        else:
            return tpEndereco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpTipoLogradouro(self, value):
        # Validate type tpTipoLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
    def validate_tpLogradouro(self, value):
        # Validate type tpLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
    def validate_tpNumeroEndereco(self, value):
        # Validate type tpNumeroEndereco, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpNumeroEndereco' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpNumeroEndereco' % {"value" : value.encode("utf-8")} )
    def validate_tpComplementoEndereco(self, value):
        # Validate type tpComplementoEndereco, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpComplementoEndereco' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpComplementoEndereco' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoBairro(self, value):
        # Validate type tpTipoBairro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoBairro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoBairro' % {"value" : value.encode("utf-8")} )
    def validate_tpBairro(self, value):
        # Validate type tpBairro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
    def validate_tpCidade(self, value):
        # Validate type tpCidade, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCidade_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCidade_patterns_, ))
    validate_tpCidade_patterns_ = [['^[0-9]$']]
    def validate_tpUF(self, value):
        # Validate type tpUF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpUF' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpUF' % {"value" : value.encode("utf-8")} )
    def validate_tpCEP(self, value):
        # Validate type tpCEP, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCEP_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCEP_patterns_, ))
    validate_tpCEP_patterns_ = [['^[0-9]{0,8}$']]
    def hasContent_(self):
        if (
            self.TipoLogradouro is not None or
            self.Logradouro is not None or
            self.NumeroEndereco is not None or
            self.ComplementoEndereco is not None or
            self.TipoBairro is not None or
            self.Bairro is not None or
            self.Cidade is not None or
            self.UF is not None or
            self.CEP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpEndereco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpEndereco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpEndereco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpEndereco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpEndereco'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpEndereco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoLogradouro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoLogradouro>%s</ns1:TipoLogradouro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoLogradouro), input_name='TipoLogradouro')), eol_))
        if self.Logradouro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Logradouro>%s</ns1:Logradouro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Logradouro), input_name='Logradouro')), eol_))
        if self.NumeroEndereco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroEndereco>%s</ns1:NumeroEndereco>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NumeroEndereco), input_name='NumeroEndereco')), eol_))
        if self.ComplementoEndereco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ComplementoEndereco>%s</ns1:ComplementoEndereco>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ComplementoEndereco), input_name='ComplementoEndereco')), eol_))
        if self.TipoBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoBairro>%s</ns1:TipoBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoBairro), input_name='TipoBairro')), eol_))
        if self.Bairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Bairro>%s</ns1:Bairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Bairro), input_name='Bairro')), eol_))
        if self.Cidade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Cidade>%s</ns1:Cidade>%s' % (self.gds_format_integer(self.Cidade, input_name='Cidade'), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:UF>%s</ns1:UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CEP>%s</ns1:CEP>%s' % (self.gds_format_integer(self.CEP, input_name='CEP'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoLogradouro':
            TipoLogradouro_ = child_.text
            TipoLogradouro_ = self.gds_validate_string(TipoLogradouro_, node, 'TipoLogradouro')
            self.TipoLogradouro = TipoLogradouro_
            # validate type tpTipoLogradouro
            self.validate_tpTipoLogradouro(self.TipoLogradouro)
        elif nodeName_ == 'Logradouro':
            Logradouro_ = child_.text
            Logradouro_ = self.gds_validate_string(Logradouro_, node, 'Logradouro')
            self.Logradouro = Logradouro_
            # validate type tpLogradouro
            self.validate_tpLogradouro(self.Logradouro)
        elif nodeName_ == 'NumeroEndereco':
            NumeroEndereco_ = child_.text
            NumeroEndereco_ = self.gds_validate_string(NumeroEndereco_, node, 'NumeroEndereco')
            self.NumeroEndereco = NumeroEndereco_
            # validate type tpNumeroEndereco
            self.validate_tpNumeroEndereco(self.NumeroEndereco)
        elif nodeName_ == 'ComplementoEndereco':
            ComplementoEndereco_ = child_.text
            ComplementoEndereco_ = self.gds_validate_string(ComplementoEndereco_, node, 'ComplementoEndereco')
            self.ComplementoEndereco = ComplementoEndereco_
            # validate type tpComplementoEndereco
            self.validate_tpComplementoEndereco(self.ComplementoEndereco)
        elif nodeName_ == 'TipoBairro':
            TipoBairro_ = child_.text
            TipoBairro_ = self.gds_validate_string(TipoBairro_, node, 'TipoBairro')
            self.TipoBairro = TipoBairro_
            # validate type tpTipoBairro
            self.validate_tpTipoBairro(self.TipoBairro)
        elif nodeName_ == 'Bairro':
            Bairro_ = child_.text
            Bairro_ = self.gds_validate_string(Bairro_, node, 'Bairro')
            self.Bairro = Bairro_
            # validate type tpBairro
            self.validate_tpBairro(self.Bairro)
        elif nodeName_ == 'Cidade':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Cidade')
            self.Cidade = ival_
            # validate type tpCidade
            self.validate_tpCidade(self.Cidade)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type tpUF
            self.validate_tpUF(self.UF)
        elif nodeName_ == 'CEP':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CEP')
            self.CEP = ival_
            # validate type tpCEP
            self.validate_tpCEP(self.CEP)
# end class tpEndereco


class tpInformacoesLote(GeneratedsSuper):
    """Informações do lote processado."""
    subclass = None
    superclass = None
    def __init__(self, NumeroLote=None, InscricaoPrestador=None, CPFCNPJRemetente=None, DataEnvioLote=None, QtdNotasProcessadas=None, TempoProcessamento=None, ValorTotalServicos=None, ValorTotalDeducoes=None):
        self.original_tagname_ = None
        self.NumeroLote = NumeroLote
        self.validate_tpNumero(self.NumeroLote)
        self.InscricaoPrestador = InscricaoPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        self.CPFCNPJRemetente = CPFCNPJRemetente
        self.validate_tpCPFCNPJ(self.CPFCNPJRemetente)
        if isinstance(DataEnvioLote, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataEnvioLote, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DataEnvioLote
        self.DataEnvioLote = initvalue_
        self.QtdNotasProcessadas = QtdNotasProcessadas
        self.validate_tpQuantidade(self.QtdNotasProcessadas)
        self.TempoProcessamento = TempoProcessamento
        self.validate_tpTempoProcessamento(self.TempoProcessamento)
        self.ValorTotalServicos = ValorTotalServicos
        self.validate_tpValor(self.ValorTotalServicos)
        self.ValorTotalDeducoes = ValorTotalDeducoes
        self.validate_tpValor(self.ValorTotalDeducoes)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpInformacoesLote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpInformacoesLote.subclass:
            return tpInformacoesLote.subclass(*args_, **kwargs_)
        else:
            return tpInformacoesLote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpCPFCNPJ(self, value):
        # Validate type tpCPFCNPJ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCPFCNPJ_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCPFCNPJ_patterns_, ))
    validate_tpCPFCNPJ_patterns_ = [['^[0-9]{11}$|^[0-9]{14}$']]
    def validate_tpQuantidade(self, value):
        # Validate type tpQuantidade, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpQuantidade' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpQuantidade' % {"value" : value} )
    def validate_tpTempoProcessamento(self, value):
        # Validate type tpTempoProcessamento, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpTempoProcessamento_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpTempoProcessamento_patterns_, ))
    validate_tpTempoProcessamento_patterns_ = [['^[0-9]{1,15}$']]
    def validate_tpValor(self, value):
        # Validate type tpValor, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpValor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpValor_patterns_, ))
    validate_tpValor_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{0,2})?$']]
    def hasContent_(self):
        if (
            self.NumeroLote is not None or
            self.InscricaoPrestador is not None or
            self.CPFCNPJRemetente is not None or
            self.DataEnvioLote is not None or
            self.QtdNotasProcessadas is not None or
            self.TempoProcessamento is not None or
            self.ValorTotalServicos is not None or
            self.ValorTotalDeducoes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpInformacoesLote', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpInformacoesLote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpInformacoesLote')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpInformacoesLote', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpInformacoesLote'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpInformacoesLote', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumeroLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroLote>%s</ns1:NumeroLote>%s' % (self.gds_format_integer(self.NumeroLote, input_name='NumeroLote'), eol_))
        if self.InscricaoPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoPrestador>%s</ns1:InscricaoPrestador>%s' % (self.gds_format_integer(self.InscricaoPrestador, input_name='InscricaoPrestador'), eol_))
        if self.CPFCNPJRemetente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CPFCNPJRemetente>%s</ns1:CPFCNPJRemetente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPFCNPJRemetente), input_name='CPFCNPJRemetente')), eol_))
        if self.DataEnvioLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DataEnvioLote>%s</ns1:DataEnvioLote>%s' % (self.gds_format_datetime(self.DataEnvioLote, input_name='DataEnvioLote'), eol_))
        if self.QtdNotasProcessadas is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:QtdNotasProcessadas>%s</ns1:QtdNotasProcessadas>%s' % (self.gds_format_float(self.QtdNotasProcessadas, input_name='QtdNotasProcessadas'), eol_))
        if self.TempoProcessamento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TempoProcessamento>%s</ns1:TempoProcessamento>%s' % (self.gds_format_integer(self.TempoProcessamento, input_name='TempoProcessamento'), eol_))
        if self.ValorTotalServicos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorTotalServicos>%s</ns1:ValorTotalServicos>%s' % (self.gds_format_float(self.ValorTotalServicos, input_name='ValorTotalServicos'), eol_))
        if self.ValorTotalDeducoes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorTotalDeducoes>%s</ns1:ValorTotalDeducoes>%s' % (self.gds_format_float(self.ValorTotalDeducoes, input_name='ValorTotalDeducoes'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumeroLote':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroLote')
            self.NumeroLote = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroLote)
        elif nodeName_ == 'InscricaoPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoPrestador')
            self.InscricaoPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoPrestador)
        elif nodeName_ == 'CPFCNPJRemetente':
            CPFCNPJRemetente_ = child_.text
            CPFCNPJRemetente_ = self.gds_validate_string(CPFCNPJRemetente_, node, 'CPFCNPJRemetente')
            self.CPFCNPJRemetente = CPFCNPJRemetente_
            # validate type tpCPFCNPJ
            self.validate_tpCPFCNPJ(self.CPFCNPJRemetente)
        elif nodeName_ == 'DataEnvioLote':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DataEnvioLote = dval_
        elif nodeName_ == 'QtdNotasProcessadas':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QtdNotasProcessadas')
            self.QtdNotasProcessadas = fval_
            # validate type tpQuantidade
            self.validate_tpQuantidade(self.QtdNotasProcessadas)
        elif nodeName_ == 'TempoProcessamento':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TempoProcessamento')
            self.TempoProcessamento = ival_
            # validate type tpTempoProcessamento
            self.validate_tpTempoProcessamento(self.TempoProcessamento)
        elif nodeName_ == 'ValorTotalServicos':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorTotalServicos')
            self.ValorTotalServicos = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorTotalServicos)
        elif nodeName_ == 'ValorTotalDeducoes':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorTotalDeducoes')
            self.ValorTotalDeducoes = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorTotalDeducoes)
# end class tpInformacoesLote


class tpLogradouroCompleto(GeneratedsSuper):
    """Informações do Logradouro com o seu Tipo."""
    subclass = None
    superclass = None
    def __init__(self, TipoLogradouro=None, NomeLogradouro=None):
        self.original_tagname_ = None
        self.TipoLogradouro = TipoLogradouro
        self.validate_tpTipoLogradouro(self.TipoLogradouro)
        self.NomeLogradouro = NomeLogradouro
        self.validate_tpLogradouro(self.NomeLogradouro)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpLogradouroCompleto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpLogradouroCompleto.subclass:
            return tpLogradouroCompleto.subclass(*args_, **kwargs_)
        else:
            return tpLogradouroCompleto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpTipoLogradouro(self, value):
        # Validate type tpTipoLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
    def validate_tpLogradouro(self, value):
        # Validate type tpLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TipoLogradouro is not None or
            self.NomeLogradouro is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpLogradouroCompleto', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpLogradouroCompleto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpLogradouroCompleto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpLogradouroCompleto', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpLogradouroCompleto'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpLogradouroCompleto', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoLogradouro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoLogradouro>%s</ns1:TipoLogradouro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoLogradouro), input_name='TipoLogradouro')), eol_))
        if self.NomeLogradouro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NomeLogradouro>%s</ns1:NomeLogradouro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NomeLogradouro), input_name='NomeLogradouro')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoLogradouro':
            TipoLogradouro_ = child_.text
            TipoLogradouro_ = self.gds_validate_string(TipoLogradouro_, node, 'TipoLogradouro')
            self.TipoLogradouro = TipoLogradouro_
            # validate type tpTipoLogradouro
            self.validate_tpTipoLogradouro(self.TipoLogradouro)
        elif nodeName_ == 'NomeLogradouro':
            NomeLogradouro_ = child_.text
            NomeLogradouro_ = self.gds_validate_string(NomeLogradouro_, node, 'NomeLogradouro')
            self.NomeLogradouro = NomeLogradouro_
            # validate type tpLogradouro
            self.validate_tpLogradouro(self.NomeLogradouro)
# end class tpLogradouroCompleto


class tpListaAlertas(GeneratedsSuper):
    """Alertas."""
    subclass = None
    superclass = None
    def __init__(self, Alerta=None):
        self.original_tagname_ = None
        if Alerta is None:
            self.Alerta = []
        else:
            self.Alerta = Alerta
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaAlertas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaAlertas.subclass:
            return tpListaAlertas.subclass(*args_, **kwargs_)
        else:
            return tpListaAlertas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Alerta
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpListaAlertas', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaAlertas')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpListaAlertas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpListaAlertas', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpListaAlertas'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpListaAlertas', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Alerta_ in self.Alerta:
            Alerta_.export(outfile, level, namespace_, name_='Alerta', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Alerta':
            obj_ = tpEvento.factory()
            obj_.build(child_)
            self.Alerta.append(obj_)
            obj_.original_tagname_ = 'Alerta'
# end class tpListaAlertas


class tpListaDeducoes(GeneratedsSuper):
    """Deduções."""
    subclass = None
    superclass = None
    def __init__(self, Deducao=None):
        self.original_tagname_ = None
        if Deducao is None:
            self.Deducao = []
        else:
            self.Deducao = Deducao
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaDeducoes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaDeducoes.subclass:
            return tpListaDeducoes.subclass(*args_, **kwargs_)
        else:
            return tpListaDeducoes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Deducao
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpListaDeducoes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaDeducoes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpListaDeducoes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpListaDeducoes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpListaDeducoes'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpListaDeducoes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Deducao_ in self.Deducao:
            Deducao_.export(outfile, level, namespace_, name_='Deducao', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Deducao':
            obj_ = tpDeducoes.factory()
            obj_.build(child_)
            self.Deducao.append(obj_)
            obj_.original_tagname_ = 'Deducao'
# end class tpListaDeducoes


class tpLoteCancelamentoNFSe(GeneratedsSuper):
    """Lista de Detalhes do Cancelamento de NFSe."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, Nota=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        if Nota is None:
            self.Nota = []
        else:
            self.Nota = Nota
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpLoteCancelamentoNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpLoteCancelamentoNFSe.subclass:
            return tpLoteCancelamentoNFSe.subclass(*args_, **kwargs_)
        else:
            return tpLoteCancelamentoNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Nota
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpLoteCancelamentoNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpLoteCancelamentoNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpLoteCancelamentoNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpLoteCancelamentoNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpLoteCancelamentoNFSe'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpLoteCancelamentoNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Nota_ in self.Nota:
            Nota_.export(outfile, level, namespace_, name_='Nota', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nota':
            obj_ = tpNotaCancelamentoNFSe.factory()
            obj_.build(child_)
            self.Nota.append(obj_)
            obj_.original_tagname_ = 'Nota'
# end class tpLoteCancelamentoNFSe


class tpNotasCancelamentoNFSe(GeneratedsSuper):
    """Lista de Detalhes do Cancelamento de NFSe."""
    subclass = None
    superclass = None
    def __init__(self, Nota=None):
        self.original_tagname_ = None
        if Nota is None:
            self.Nota = []
        else:
            self.Nota = Nota
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpNotasCancelamentoNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpNotasCancelamentoNFSe.subclass:
            return tpNotasCancelamentoNFSe.subclass(*args_, **kwargs_)
        else:
            return tpNotasCancelamentoNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Nota
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpNotasCancelamentoNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpNotasCancelamentoNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpNotasCancelamentoNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpNotasCancelamentoNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpNotasCancelamentoNFSe'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpNotasCancelamentoNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Nota_ in self.Nota:
            Nota_.export(outfile, level, namespace_, name_='Nota', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nota':
            obj_ = tpNotaCancelamentoNFSe.factory()
            obj_.build(child_)
            self.Nota.append(obj_)
            obj_.original_tagname_ = 'Nota'
# end class tpNotasCancelamentoNFSe


class tpRetornoNotasCancelamentoNFSe(GeneratedsSuper):
    """Lista de Detalhes do Cancelamento de NFSe."""
    subclass = None
    superclass = None
    def __init__(self, Nota=None):
        self.original_tagname_ = None
        if Nota is None:
            self.Nota = []
        else:
            self.Nota = Nota
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpRetornoNotasCancelamentoNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpRetornoNotasCancelamentoNFSe.subclass:
            return tpRetornoNotasCancelamentoNFSe.subclass(*args_, **kwargs_)
        else:
            return tpRetornoNotasCancelamentoNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Nota
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpRetornoNotasCancelamentoNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpRetornoNotasCancelamentoNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpRetornoNotasCancelamentoNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpRetornoNotasCancelamentoNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpRetornoNotasCancelamentoNFSe'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpRetornoNotasCancelamentoNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Nota_ in self.Nota:
            Nota_.export(outfile, level, namespace_, name_='Nota', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nota':
            obj_ = tpNotaCancelamentoNFSe.factory()
            obj_.build(child_)
            self.Nota.append(obj_)
            obj_.original_tagname_ = 'Nota'
# end class tpRetornoNotasCancelamentoNFSe


class tpLoteConsultaNFSe(GeneratedsSuper):
    """Lista de Detalhes da Consulta de NFSe."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, NotaConsulta=None, RPSConsulta=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.NotaConsulta = NotaConsulta
        self.RPSConsulta = RPSConsulta
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpLoteConsultaNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpLoteConsultaNFSe.subclass:
            return tpLoteConsultaNFSe.subclass(*args_, **kwargs_)
        else:
            return tpLoteConsultaNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.NotaConsulta is not None or
            self.RPSConsulta is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpLoteConsultaNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpLoteConsultaNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpLoteConsultaNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpLoteConsultaNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpLoteConsultaNFSe'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpLoteConsultaNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NotaConsulta is not None:
            self.NotaConsulta.export(outfile, level, namespace_, name_='NotaConsulta', pretty_print=pretty_print)
        if self.RPSConsulta is not None:
            self.RPSConsulta.export(outfile, level, namespace_, name_='RPSConsulta', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NotaConsulta':
            obj_ = tpNotasConsultaNFSe.factory()
            obj_.build(child_)
            self.NotaConsulta = obj_
            obj_.original_tagname_ = 'NotaConsulta'
        elif nodeName_ == 'RPSConsulta':
            obj_ = tpRPSsConsultaNFSe.factory()
            obj_.build(child_)
            self.RPSConsulta = obj_
            obj_.original_tagname_ = 'RPSConsulta'
# end class tpLoteConsultaNFSe


class tpNotasConsultaNFSe(GeneratedsSuper):
    """Lista de Detalhes da Consulta de NFSe."""
    subclass = None
    superclass = None
    def __init__(self, Nota=None):
        self.original_tagname_ = None
        if Nota is None:
            self.Nota = []
        else:
            self.Nota = Nota
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpNotasConsultaNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpNotasConsultaNFSe.subclass:
            return tpNotasConsultaNFSe.subclass(*args_, **kwargs_)
        else:
            return tpNotasConsultaNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Nota
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpNotasConsultaNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpNotasConsultaNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpNotasConsultaNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpNotasConsultaNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpNotasConsultaNFSe'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpNotasConsultaNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Nota_ in self.Nota:
            Nota_.export(outfile, level, namespace_, name_='Nota', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nota':
            obj_ = tpNotaConsultaNFSe.factory()
            obj_.build(child_)
            self.Nota.append(obj_)
            obj_.original_tagname_ = 'Nota'
# end class tpNotasConsultaNFSe


class tpNotaConsultaNFSe(GeneratedsSuper):
    """Tipo Detalhes da Nota da Consulta de NFSe."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, InscricaoMunicipalPrestador=None, NumeroNota=None, CodigoVerificacao=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.InscricaoMunicipalPrestador = InscricaoMunicipalPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        self.NumeroNota = NumeroNota
        self.validate_tpNumero(self.NumeroNota)
        self.CodigoVerificacao = CodigoVerificacao
        self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpNotaConsultaNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpNotaConsultaNFSe.subclass:
            return tpNotaConsultaNFSe.subclass(*args_, **kwargs_)
        else:
            return tpNotaConsultaNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpCodigoVerificacao(self, value):
        # Validate type tpCodigoVerificacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InscricaoMunicipalPrestador is not None or
            self.NumeroNota is not None or
            self.CodigoVerificacao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpNotaConsultaNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpNotaConsultaNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpNotaConsultaNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpNotaConsultaNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpNotaConsultaNFSe'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpNotaConsultaNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoMunicipalPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoMunicipalPrestador>%s</ns1:InscricaoMunicipalPrestador>%s' % (self.gds_format_integer(self.InscricaoMunicipalPrestador, input_name='InscricaoMunicipalPrestador'), eol_))
        if self.NumeroNota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroNota>%s</ns1:NumeroNota>%s' % (self.gds_format_integer(self.NumeroNota, input_name='NumeroNota'), eol_))
        if self.CodigoVerificacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CodigoVerificacao>%s</ns1:CodigoVerificacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CodigoVerificacao), input_name='CodigoVerificacao')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoMunicipalPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipalPrestador')
            self.InscricaoMunicipalPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        elif nodeName_ == 'NumeroNota':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNota')
            self.NumeroNota = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroNota)
        elif nodeName_ == 'CodigoVerificacao':
            CodigoVerificacao_ = child_.text
            CodigoVerificacao_ = self.gds_validate_string(CodigoVerificacao_, node, 'CodigoVerificacao')
            self.CodigoVerificacao = CodigoVerificacao_
            # validate type tpCodigoVerificacao
            self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
# end class tpNotaConsultaNFSe


class tpRPSsConsultaNFSe(GeneratedsSuper):
    """Lista de Detalhes da Consulta de NFSe."""
    subclass = None
    superclass = None
    def __init__(self, RPS=None):
        self.original_tagname_ = None
        if RPS is None:
            self.RPS = []
        else:
            self.RPS = RPS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpRPSsConsultaNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpRPSsConsultaNFSe.subclass:
            return tpRPSsConsultaNFSe.subclass(*args_, **kwargs_)
        else:
            return tpRPSsConsultaNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RPS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpRPSsConsultaNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpRPSsConsultaNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpRPSsConsultaNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpRPSsConsultaNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpRPSsConsultaNFSe'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpRPSsConsultaNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RPS_ in self.RPS:
            RPS_.export(outfile, level, namespace_, name_='RPS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RPS':
            obj_ = tpRPSConsultaNFSe.factory()
            obj_.build(child_)
            self.RPS.append(obj_)
            obj_.original_tagname_ = 'RPS'
# end class tpRPSsConsultaNFSe


class tpRPSConsultaNFSe(GeneratedsSuper):
    """Tipo Detalhes do RPSSe."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, InscricaoMunicipalPrestador=None, NumeroRPS=None, SeriePrestacao=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.InscricaoMunicipalPrestador = InscricaoMunicipalPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        self.NumeroRPS = NumeroRPS
        self.validate_tpNumero(self.NumeroRPS)
        self.SeriePrestacao = SeriePrestacao
        self.validate_tpSeriePrestacao(self.SeriePrestacao)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpRPSConsultaNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpRPSConsultaNFSe.subclass:
            return tpRPSConsultaNFSe.subclass(*args_, **kwargs_)
        else:
            return tpRPSConsultaNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpSeriePrestacao(self, value):
        # Validate type tpSeriePrestacao, a restriction on xs:byte.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpSeriePrestacao' % {"value" : value} )
            if value > 99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpSeriePrestacao' % {"value" : value} )
    def hasContent_(self):
        if (
            self.InscricaoMunicipalPrestador is not None or
            self.NumeroRPS is not None or
            self.SeriePrestacao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpRPSConsultaNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpRPSConsultaNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpRPSConsultaNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpRPSConsultaNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpRPSConsultaNFSe'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpRPSConsultaNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoMunicipalPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoMunicipalPrestador>%s</ns1:InscricaoMunicipalPrestador>%s' % (self.gds_format_integer(self.InscricaoMunicipalPrestador, input_name='InscricaoMunicipalPrestador'), eol_))
        if self.NumeroRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroRPS>%s</ns1:NumeroRPS>%s' % (self.gds_format_integer(self.NumeroRPS, input_name='NumeroRPS'), eol_))
        if self.SeriePrestacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SeriePrestacao>%s</ns1:SeriePrestacao>%s' % (self.gds_format_integer(self.SeriePrestacao, input_name='SeriePrestacao'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoMunicipalPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipalPrestador')
            self.InscricaoMunicipalPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        elif nodeName_ == 'NumeroRPS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroRPS')
            self.NumeroRPS = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroRPS)
        elif nodeName_ == 'SeriePrestacao':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SeriePrestacao')
            self.SeriePrestacao = ival_
            # validate type tpSeriePrestacao
            self.validate_tpSeriePrestacao(self.SeriePrestacao)
# end class tpRPSConsultaNFSe


class tpListaDetalhesConsultaRPS(GeneratedsSuper):
    """Lista de Detalhes da Consulta RPS"""
    subclass = None
    superclass = None
    def __init__(self, Detalhe=None):
        self.original_tagname_ = None
        if Detalhe is None:
            self.Detalhe = []
        else:
            self.Detalhe = Detalhe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaDetalhesConsultaRPS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaDetalhesConsultaRPS.subclass:
            return tpListaDetalhesConsultaRPS.subclass(*args_, **kwargs_)
        else:
            return tpListaDetalhesConsultaRPS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Detalhe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpListaDetalhesConsultaRPS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaDetalhesConsultaRPS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpListaDetalhesConsultaRPS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpListaDetalhesConsultaRPS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpListaDetalhesConsultaRPS'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpListaDetalhesConsultaRPS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Detalhe_ in self.Detalhe:
            Detalhe_.export(outfile, level, namespace_, name_='Detalhe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Detalhe':
            obj_ = tpDetalhesConsultaRPS.factory()
            obj_.build(child_)
            self.Detalhe.append(obj_)
            obj_.original_tagname_ = 'Detalhe'
# end class tpListaDetalhesConsultaRPS


class tpListaErros(GeneratedsSuper):
    """Erros."""
    subclass = None
    superclass = None
    def __init__(self, Erro=None):
        self.original_tagname_ = None
        if Erro is None:
            self.Erro = []
        else:
            self.Erro = Erro
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaErros)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaErros.subclass:
            return tpListaErros.subclass(*args_, **kwargs_)
        else:
            return tpListaErros(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Erro
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpListaErros', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaErros')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpListaErros')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpListaErros', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpListaErros'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpListaErros', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Erro_ in self.Erro:
            Erro_.export(outfile, level, namespace_, name_='Erro', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Erro':
            obj_ = tpEvento.factory()
            obj_.build(child_)
            self.Erro.append(obj_)
            obj_.original_tagname_ = 'Erro'
# end class tpListaErros


class tpListaItens(GeneratedsSuper):
    """Itens de Serviço."""
    subclass = None
    superclass = None
    def __init__(self, Item=None):
        self.original_tagname_ = None
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaItens)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaItens.subclass:
            return tpListaItens.subclass(*args_, **kwargs_)
        else:
            return tpListaItens(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Item
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpListaItens', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaItens')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpListaItens')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpListaItens', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpListaItens'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpListaItens', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Item':
            obj_ = tpItens.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
# end class tpListaItens


class tpListaNFSeRPS(GeneratedsSuper):
    """NFSE e seu respectivo RPS"""
    subclass = None
    superclass = None
    def __init__(self, ChaveNFSeRPS=None):
        self.original_tagname_ = None
        if ChaveNFSeRPS is None:
            self.ChaveNFSeRPS = []
        else:
            self.ChaveNFSeRPS = ChaveNFSeRPS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaNFSeRPS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaNFSeRPS.subclass:
            return tpListaNFSeRPS.subclass(*args_, **kwargs_)
        else:
            return tpListaNFSeRPS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ChaveNFSeRPS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpListaNFSeRPS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaNFSeRPS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpListaNFSeRPS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpListaNFSeRPS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpListaNFSeRPS'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpListaNFSeRPS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ChaveNFSeRPS_ in self.ChaveNFSeRPS:
            ChaveNFSeRPS_.export(outfile, level, namespace_, name_='ChaveNFSeRPS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChaveNFSeRPS':
            obj_ = tpChaveNFeRPS.factory()
            obj_.build(child_)
            self.ChaveNFSeRPS.append(obj_)
            obj_.original_tagname_ = 'ChaveNFSeRPS'
# end class tpListaNFSeRPS


class tpListaNFSe(GeneratedsSuper):
    """Lista de NFSE consultada"""
    subclass = None
    superclass = None
    def __init__(self, ConsultaNFSe=None):
        self.original_tagname_ = None
        if ConsultaNFSe is None:
            self.ConsultaNFSe = []
        else:
            self.ConsultaNFSe = ConsultaNFSe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaNFSe.subclass:
            return tpListaNFSe.subclass(*args_, **kwargs_)
        else:
            return tpListaNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ConsultaNFSe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpListaNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpListaNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpListaNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpListaNFSe'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpListaNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ConsultaNFSe_ in self.ConsultaNFSe:
            ConsultaNFSe_.export(outfile, level, namespace_, name_='ConsultaNFSe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConsultaNFSe':
            obj_ = tpConsultaNFSe.factory()
            obj_.build(child_)
            self.ConsultaNFSe.append(obj_)
            obj_.original_tagname_ = 'ConsultaNFSe'
# end class tpListaNFSe


class tpListaNFSeConsultaNota(GeneratedsSuper):
    """Lista de NFSE consultada"""
    subclass = None
    superclass = None
    def __init__(self, Nota=None):
        self.original_tagname_ = None
        if Nota is None:
            self.Nota = []
        else:
            self.Nota = Nota
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaNFSeConsultaNota)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaNFSeConsultaNota.subclass:
            return tpListaNFSeConsultaNota.subclass(*args_, **kwargs_)
        else:
            return tpListaNFSeConsultaNota(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Nota
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpListaNFSeConsultaNota', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaNFSeConsultaNota')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpListaNFSeConsultaNota')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpListaNFSeConsultaNota', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpListaNFSeConsultaNota'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpListaNFSeConsultaNota', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Nota_ in self.Nota:
            Nota_.export(outfile, level, namespace_, name_='Nota', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Nota':
            obj_ = tpNFSe.factory()
            obj_.build(child_)
            self.Nota.append(obj_)
            obj_.original_tagname_ = 'Nota'
# end class tpListaNFSeConsultaNota


class tpLote(GeneratedsSuper):
    """Lote de RPS"""
    subclass = None
    superclass = None
    def __init__(self, Id=None, RPS=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        if RPS is None:
            self.RPS = []
        else:
            self.RPS = RPS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpLote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpLote.subclass:
            return tpLote.subclass(*args_, **kwargs_)
        else:
            return tpLote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RPS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpLote', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpLote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpLote')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpLote', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpLote'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpLote', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RPS_ in self.RPS:
            RPS_.export(outfile, level, namespace_, name_='RPS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RPS':
            obj_ = tpRPS.factory()
            obj_.build(child_)
            self.RPS.append(obj_)
            obj_.original_tagname_ = 'RPS'
# end class tpLote


class tpNFSe(GeneratedsSuper):
    """Tipo que representa uma NFSe"""
    subclass = None
    superclass = None
    def __init__(self, NumeroNota=None, DataProcessamento=None, NumeroLote=None, CodigoVerificacao=None, Assinatura=None, InscricaoMunicipalPrestador=None, RazaoSocialPrestador=None, TipoRPS=None, SerieRPS=None, NumeroRPS=None, DataEmissaoRPS=None, SituacaoRPS=None, SerieRPSSubstituido=None, NumeroRPSSubstituido=None, NumeroNFSeSubstituida=None, DataEmissaoNFSeSubstituida=None, SeriePrestacao=None, InscricaoMunicipalTomador=None, CPFCNPJTomador=None, RazaoSocialTomador=None, DocTomadorEstrangeiro=None, TipoLogradouroTomador=None, LogradouroTomador=None, NumeroEnderecoTomador=None, ComplementoEnderecoTomador=None, TipoBairroTomador=None, BairroTomador=None, CidadeTomador=None, CidadeTomadorDescricao=None, CEPTomador=None, EmailTomador=None, CodigoAtividade=None, AliquotaAtividade=None, TipoRecolhimento=None, MunicipioPrestacao=None, MunicipioPrestacaoDescricao=None, Operacao=None, Tributacao=None, ValorPIS=None, ValorCOFINS=None, ValorINSS=None, ValorIR=None, ValorCSLL=None, AliquotaPIS=None, AliquotaCOFINS=None, AliquotaINSS=None, AliquotaIR=None, AliquotaCSLL=None, DescricaoRPS=None, DDDPrestador=None, TelefonePrestador=None, DDDTomador=None, TelefoneTomador=None, MotCancelamento=None, CPFCNPJIntermediario=None, Deducoes=None, Itens=None):
        self.original_tagname_ = None
        self.NumeroNota = NumeroNota
        self.validate_tpNumero(self.NumeroNota)
        if isinstance(DataProcessamento, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataProcessamento, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DataProcessamento
        self.DataProcessamento = initvalue_
        self.NumeroLote = NumeroLote
        self.validate_tpNumero(self.NumeroLote)
        self.CodigoVerificacao = CodigoVerificacao
        self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
        self.Assinatura = Assinatura
        self.validate_tpAssinatura(self.Assinatura)
        self.InscricaoMunicipalPrestador = InscricaoMunicipalPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        self.RazaoSocialPrestador = RazaoSocialPrestador
        self.validate_tpRazaoSocialPrestador(self.RazaoSocialPrestador)
        self.TipoRPS = TipoRPS
        self.validate_tpTipoRPS(self.TipoRPS)
        self.SerieRPS = SerieRPS
        self.validate_tpSerieRPS(self.SerieRPS)
        self.NumeroRPS = NumeroRPS
        self.validate_tpNumero(self.NumeroRPS)
        if isinstance(DataEmissaoRPS, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataEmissaoRPS, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DataEmissaoRPS
        self.DataEmissaoRPS = initvalue_
        self.SituacaoRPS = SituacaoRPS
        self.validate_tpSituacaoRPS(self.SituacaoRPS)
        self.SerieRPSSubstituido = SerieRPSSubstituido
        self.validate_tpSerieRPSSubstituido(self.SerieRPSSubstituido)
        self.NumeroRPSSubstituido = NumeroRPSSubstituido
        self.validate_tpNumeroComZero(self.NumeroRPSSubstituido)
        self.NumeroNFSeSubstituida = NumeroNFSeSubstituida
        self.validate_tpNumeroComZero(self.NumeroNFSeSubstituida)
        self.DataEmissaoNFSeSubstituida = DataEmissaoNFSeSubstituida
        self.validate_tpDataHoraNulo(self.DataEmissaoNFSeSubstituida)
        self.SeriePrestacao = SeriePrestacao
        self.validate_tpSeriePrestacao(self.SeriePrestacao)
        self.InscricaoMunicipalTomador = InscricaoMunicipalTomador
        self.validate_tpInscricaoMunicipalNulo(self.InscricaoMunicipalTomador)
        self.CPFCNPJTomador = CPFCNPJTomador
        self.validate_tpCPFCNPJ(self.CPFCNPJTomador)
        self.RazaoSocialTomador = RazaoSocialTomador
        self.validate_tpRazaoSocial(self.RazaoSocialTomador)
        self.DocTomadorEstrangeiro = DocTomadorEstrangeiro
        self.validate_tpDocTomadorEstrangeiro(self.DocTomadorEstrangeiro)
        self.TipoLogradouroTomador = TipoLogradouroTomador
        self.validate_tpTipoLogradouro(self.TipoLogradouroTomador)
        self.LogradouroTomador = LogradouroTomador
        self.validate_tpLogradouro(self.LogradouroTomador)
        self.NumeroEnderecoTomador = NumeroEnderecoTomador
        self.validate_tpNumeroEndereco(self.NumeroEnderecoTomador)
        self.ComplementoEnderecoTomador = ComplementoEnderecoTomador
        self.validate_tpComplementoEndereco(self.ComplementoEnderecoTomador)
        self.TipoBairroTomador = TipoBairroTomador
        self.validate_tpTipoBairro(self.TipoBairroTomador)
        self.BairroTomador = BairroTomador
        self.validate_tpBairro(self.BairroTomador)
        self.CidadeTomador = CidadeTomador
        self.validate_tpCodCidade(self.CidadeTomador)
        self.CidadeTomadorDescricao = CidadeTomadorDescricao
        self.validate_tpCidadeTomadorDescricao(self.CidadeTomadorDescricao)
        self.CEPTomador = CEPTomador
        self.validate_tpCEPNulo(self.CEPTomador)
        self.EmailTomador = EmailTomador
        self.validate_tpEmail(self.EmailTomador)
        self.CodigoAtividade = CodigoAtividade
        self.validate_tpCodigoAtividade(self.CodigoAtividade)
        self.AliquotaAtividade = AliquotaAtividade
        self.validate_tpAliquota(self.AliquotaAtividade)
        self.TipoRecolhimento = TipoRecolhimento
        self.validate_tpTipoRecolhimento(self.TipoRecolhimento)
        self.MunicipioPrestacao = MunicipioPrestacao
        self.validate_tpCodCidade(self.MunicipioPrestacao)
        self.MunicipioPrestacaoDescricao = MunicipioPrestacaoDescricao
        self.validate_tpCidadeDescricao(self.MunicipioPrestacaoDescricao)
        self.Operacao = Operacao
        self.validate_tpOperacao(self.Operacao)
        self.Tributacao = Tributacao
        self.validate_tpTributacao(self.Tributacao)
        self.ValorPIS = ValorPIS
        self.validate_tpValor(self.ValorPIS)
        self.ValorCOFINS = ValorCOFINS
        self.validate_tpValor(self.ValorCOFINS)
        self.ValorINSS = ValorINSS
        self.validate_tpValor(self.ValorINSS)
        self.ValorIR = ValorIR
        self.validate_tpValor(self.ValorIR)
        self.ValorCSLL = ValorCSLL
        self.validate_tpValor(self.ValorCSLL)
        self.AliquotaPIS = AliquotaPIS
        self.validate_tpAliquota(self.AliquotaPIS)
        self.AliquotaCOFINS = AliquotaCOFINS
        self.validate_tpAliquota(self.AliquotaCOFINS)
        self.AliquotaINSS = AliquotaINSS
        self.validate_tpAliquota(self.AliquotaINSS)
        self.AliquotaIR = AliquotaIR
        self.validate_tpAliquota(self.AliquotaIR)
        self.AliquotaCSLL = AliquotaCSLL
        self.validate_tpAliquota(self.AliquotaCSLL)
        self.DescricaoRPS = DescricaoRPS
        self.validate_tpDescricaoRPS(self.DescricaoRPS)
        self.DDDPrestador = DDDPrestador
        self.validate_tpDDDNulo(self.DDDPrestador)
        self.TelefonePrestador = TelefonePrestador
        self.validate_tpFoneNulo(self.TelefonePrestador)
        self.DDDTomador = DDDTomador
        self.validate_tpDDDNulo(self.DDDTomador)
        self.TelefoneTomador = TelefoneTomador
        self.validate_tpFoneNulo(self.TelefoneTomador)
        self.MotCancelamento = MotCancelamento
        self.validate_tpMotCancelamento(self.MotCancelamento)
        self.CPFCNPJIntermediario = CPFCNPJIntermediario
        self.validate_tpCPFCNPJnulo(self.CPFCNPJIntermediario)
        self.Deducoes = Deducoes
        self.Itens = Itens
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpNFSe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpNFSe.subclass:
            return tpNFSe.subclass(*args_, **kwargs_)
        else:
            return tpNFSe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpCodigoVerificacao(self, value):
        # Validate type tpCodigoVerificacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
    def validate_tpAssinatura(self, value):
        # Validate type tpAssinatura, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpRazaoSocialPrestador(self, value):
        # Validate type tpRazaoSocialPrestador, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpRazaoSocialPrestador' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpRazaoSocialPrestador' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoRPS(self, value):
        # Validate type tpTipoRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['RPS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTipoRPS' % {"value" : value.encode("utf-8")} )
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpSerieRPS(self, value):
        # Validate type tpSerieRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpSerieRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpDataHora(self, value):
        # Validate type tpDataHora, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpSituacaoRPS(self, value):
        # Validate type tpSituacaoRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['N', 'C']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpSituacaoRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpSerieRPSSubstituido(self, value):
        # Validate type tpSerieRPSSubstituido, a restriction on None.
        pass
    def validate_tpNumeroComZero(self, value):
        # Validate type tpNumeroComZero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumeroComZero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumeroComZero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumeroComZero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumeroComZero_patterns_, ))
    validate_tpNumeroComZero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpDataHoraNulo(self, value):
        # Validate type tpDataHoraNulo, a restriction on None.
        pass
    def validate_tpSeriePrestacao(self, value):
        # Validate type tpSeriePrestacao, a restriction on xs:byte.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpSeriePrestacao' % {"value" : value} )
            if value > 99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpSeriePrestacao' % {"value" : value} )
    def validate_tpInscricaoMunicipalNulo(self, value):
        # Validate type tpInscricaoMunicipalNulo, a restriction on None.
        pass
    def validate_tpCPFCNPJ(self, value):
        # Validate type tpCPFCNPJ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCPFCNPJ_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCPFCNPJ_patterns_, ))
    validate_tpCPFCNPJ_patterns_ = [['^[0-9]{11}$|^[0-9]{14}$']]
    def validate_tpRazaoSocial(self, value):
        # Validate type tpRazaoSocial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
    def validate_tpDocTomadorEstrangeiro(self, value):
        # Validate type tpDocTomadorEstrangeiro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDocTomadorEstrangeiro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpDocTomadorEstrangeiro' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoLogradouro(self, value):
        # Validate type tpTipoLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
    def validate_tpLogradouro(self, value):
        # Validate type tpLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
    def validate_tpNumeroEndereco(self, value):
        # Validate type tpNumeroEndereco, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpNumeroEndereco' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpNumeroEndereco' % {"value" : value.encode("utf-8")} )
    def validate_tpComplementoEndereco(self, value):
        # Validate type tpComplementoEndereco, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpComplementoEndereco' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpComplementoEndereco' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoBairro(self, value):
        # Validate type tpTipoBairro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoBairro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoBairro' % {"value" : value.encode("utf-8")} )
    def validate_tpBairro(self, value):
        # Validate type tpBairro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
    def validate_tpCodCidade(self, value):
        # Validate type tpCodCidade, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpCodCidade' % {"value" : value} )
    def validate_tpCidadeTomadorDescricao(self, value):
        # Validate type tpCidadeTomadorDescricao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCidadeTomadorDescricao' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCidadeTomadorDescricao' % {"value" : value.encode("utf-8")} )
    def validate_tpCEPNulo(self, value):
        # Validate type tpCEPNulo, a restriction on None.
        pass
    def validate_tpEmail(self, value):
        # Validate type tpEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpEmail' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpEmail' % {"value" : value.encode("utf-8")} )
    def validate_tpCodigoAtividade(self, value):
        # Validate type tpCodigoAtividade, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCodigoAtividade_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCodigoAtividade_patterns_, ))
    validate_tpCodigoAtividade_patterns_ = [['^[0-9]{9}$']]
    def validate_tpAliquota(self, value):
        # Validate type tpAliquota, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpAliquota' % {"value" : value} )
            if len(str(value)) >= 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpAliquota' % {"value" : value} )
    def validate_tpTipoRecolhimento(self, value):
        # Validate type tpTipoRecolhimento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'R']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTipoRecolhimento' % {"value" : value.encode("utf-8")} )
    def validate_tpCidadeDescricao(self, value):
        # Validate type tpCidadeDescricao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCidadeDescricao' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCidadeDescricao' % {"value" : value.encode("utf-8")} )
    def validate_tpOperacao(self, value):
        # Validate type tpOperacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'B', 'C', 'D', 'J']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpOperacao' % {"value" : value.encode("utf-8")} )
    def validate_tpTributacao(self, value):
        # Validate type tpTributacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['C', 'F', 'K', 'E', 'T', 'H', 'G', 'N', 'M']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTributacao' % {"value" : value.encode("utf-8")} )
    def validate_tpValor(self, value):
        # Validate type tpValor, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpValor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpValor_patterns_, ))
    validate_tpValor_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{0,2})?$']]
    def validate_tpDescricaoRPS(self, value):
        # Validate type tpDescricaoRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 1500:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDescricaoRPS' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpDescricaoRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpDDDNulo(self, value):
        # Validate type tpDDDNulo, a restriction on None.
        pass
    def validate_tpFoneNulo(self, value):
        # Validate type tpFoneNulo, a restriction on None.
        pass
    def validate_tpMotCancelamento(self, value):
        # Validate type tpMotCancelamento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpMotCancelamento' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpMotCancelamento' % {"value" : value.encode("utf-8")} )
    def validate_tpCPFCNPJnulo(self, value):
        # Validate type tpCPFCNPJnulo, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.NumeroNota is not None or
            self.DataProcessamento is not None or
            self.NumeroLote is not None or
            self.CodigoVerificacao is not None or
            self.Assinatura is not None or
            self.InscricaoMunicipalPrestador is not None or
            self.RazaoSocialPrestador is not None or
            self.TipoRPS is not None or
            self.SerieRPS is not None or
            self.NumeroRPS is not None or
            self.DataEmissaoRPS is not None or
            self.SituacaoRPS is not None or
            self.SerieRPSSubstituido is not None or
            self.NumeroRPSSubstituido is not None or
            self.NumeroNFSeSubstituida is not None or
            self.DataEmissaoNFSeSubstituida is not None or
            self.SeriePrestacao is not None or
            self.InscricaoMunicipalTomador is not None or
            self.CPFCNPJTomador is not None or
            self.RazaoSocialTomador is not None or
            self.DocTomadorEstrangeiro is not None or
            self.TipoLogradouroTomador is not None or
            self.LogradouroTomador is not None or
            self.NumeroEnderecoTomador is not None or
            self.ComplementoEnderecoTomador is not None or
            self.TipoBairroTomador is not None or
            self.BairroTomador is not None or
            self.CidadeTomador is not None or
            self.CidadeTomadorDescricao is not None or
            self.CEPTomador is not None or
            self.EmailTomador is not None or
            self.CodigoAtividade is not None or
            self.AliquotaAtividade is not None or
            self.TipoRecolhimento is not None or
            self.MunicipioPrestacao is not None or
            self.MunicipioPrestacaoDescricao is not None or
            self.Operacao is not None or
            self.Tributacao is not None or
            self.ValorPIS is not None or
            self.ValorCOFINS is not None or
            self.ValorINSS is not None or
            self.ValorIR is not None or
            self.ValorCSLL is not None or
            self.AliquotaPIS is not None or
            self.AliquotaCOFINS is not None or
            self.AliquotaINSS is not None or
            self.AliquotaIR is not None or
            self.AliquotaCSLL is not None or
            self.DescricaoRPS is not None or
            self.DDDPrestador is not None or
            self.TelefonePrestador is not None or
            self.DDDTomador is not None or
            self.TelefoneTomador is not None or
            self.MotCancelamento is not None or
            self.CPFCNPJIntermediario is not None or
            self.Deducoes is not None or
            self.Itens is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpNFSe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpNFSe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpNFSe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpNFSe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpNFSe'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpNFSe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumeroNota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroNota>%s</ns1:NumeroNota>%s' % (self.gds_format_integer(self.NumeroNota, input_name='NumeroNota'), eol_))
        if self.DataProcessamento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DataProcessamento>%s</ns1:DataProcessamento>%s' % (self.gds_format_datetime(self.DataProcessamento, input_name='DataProcessamento'), eol_))
        if self.NumeroLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroLote>%s</ns1:NumeroLote>%s' % (self.gds_format_integer(self.NumeroLote, input_name='NumeroLote'), eol_))
        if self.CodigoVerificacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CodigoVerificacao>%s</ns1:CodigoVerificacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CodigoVerificacao), input_name='CodigoVerificacao')), eol_))
        if self.Assinatura is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Assinatura>%s</ns1:Assinatura>%s' % (self.gds_format_base64(self.Assinatura, input_name='Assinatura'), eol_))
        if self.InscricaoMunicipalPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoMunicipalPrestador>%s</ns1:InscricaoMunicipalPrestador>%s' % (self.gds_format_integer(self.InscricaoMunicipalPrestador, input_name='InscricaoMunicipalPrestador'), eol_))
        if self.RazaoSocialPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:RazaoSocialPrestador>%s</ns1:RazaoSocialPrestador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RazaoSocialPrestador), input_name='RazaoSocialPrestador')), eol_))
        if self.TipoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoRPS>%s</ns1:TipoRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoRPS), input_name='TipoRPS')), eol_))
        if self.SerieRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SerieRPS>%s</ns1:SerieRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SerieRPS), input_name='SerieRPS')), eol_))
        if self.NumeroRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroRPS>%s</ns1:NumeroRPS>%s' % (self.gds_format_integer(self.NumeroRPS, input_name='NumeroRPS'), eol_))
        if self.DataEmissaoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DataEmissaoRPS>%s</ns1:DataEmissaoRPS>%s' % (self.gds_format_datetime(self.DataEmissaoRPS, input_name='DataEmissaoRPS'), eol_))
        if self.SituacaoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SituacaoRPS>%s</ns1:SituacaoRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SituacaoRPS), input_name='SituacaoRPS')), eol_))
        if self.SerieRPSSubstituido is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SerieRPSSubstituido>%s</ns1:SerieRPSSubstituido>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SerieRPSSubstituido), input_name='SerieRPSSubstituido')), eol_))
        if self.NumeroRPSSubstituido is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroRPSSubstituido>%s</ns1:NumeroRPSSubstituido>%s' % (self.gds_format_integer(self.NumeroRPSSubstituido, input_name='NumeroRPSSubstituido'), eol_))
        if self.NumeroNFSeSubstituida is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroNFSeSubstituida>%s</ns1:NumeroNFSeSubstituida>%s' % (self.gds_format_integer(self.NumeroNFSeSubstituida, input_name='NumeroNFSeSubstituida'), eol_))
        if self.DataEmissaoNFSeSubstituida is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DataEmissaoNFSeSubstituida>%s</ns1:DataEmissaoNFSeSubstituida>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataEmissaoNFSeSubstituida), input_name='DataEmissaoNFSeSubstituida')), eol_))
        if self.SeriePrestacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SeriePrestacao>%s</ns1:SeriePrestacao>%s' % (self.gds_format_integer(self.SeriePrestacao, input_name='SeriePrestacao'), eol_))
        if self.InscricaoMunicipalTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoMunicipalTomador>%s</ns1:InscricaoMunicipalTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.InscricaoMunicipalTomador), input_name='InscricaoMunicipalTomador')), eol_))
        if self.CPFCNPJTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CPFCNPJTomador>%s</ns1:CPFCNPJTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPFCNPJTomador), input_name='CPFCNPJTomador')), eol_))
        if self.RazaoSocialTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:RazaoSocialTomador>%s</ns1:RazaoSocialTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RazaoSocialTomador), input_name='RazaoSocialTomador')), eol_))
        if self.DocTomadorEstrangeiro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DocTomadorEstrangeiro>%s</ns1:DocTomadorEstrangeiro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocTomadorEstrangeiro), input_name='DocTomadorEstrangeiro')), eol_))
        if self.TipoLogradouroTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoLogradouroTomador>%s</ns1:TipoLogradouroTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoLogradouroTomador), input_name='TipoLogradouroTomador')), eol_))
        if self.LogradouroTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:LogradouroTomador>%s</ns1:LogradouroTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LogradouroTomador), input_name='LogradouroTomador')), eol_))
        if self.NumeroEnderecoTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroEnderecoTomador>%s</ns1:NumeroEnderecoTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NumeroEnderecoTomador), input_name='NumeroEnderecoTomador')), eol_))
        if self.ComplementoEnderecoTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ComplementoEnderecoTomador>%s</ns1:ComplementoEnderecoTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ComplementoEnderecoTomador), input_name='ComplementoEnderecoTomador')), eol_))
        if self.TipoBairroTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoBairroTomador>%s</ns1:TipoBairroTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoBairroTomador), input_name='TipoBairroTomador')), eol_))
        if self.BairroTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:BairroTomador>%s</ns1:BairroTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BairroTomador), input_name='BairroTomador')), eol_))
        if self.CidadeTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CidadeTomador>%s</ns1:CidadeTomador>%s' % (self.gds_format_integer(self.CidadeTomador, input_name='CidadeTomador'), eol_))
        if self.CidadeTomadorDescricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CidadeTomadorDescricao>%s</ns1:CidadeTomadorDescricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CidadeTomadorDescricao), input_name='CidadeTomadorDescricao')), eol_))
        if self.CEPTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CEPTomador>%s</ns1:CEPTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEPTomador), input_name='CEPTomador')), eol_))
        if self.EmailTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:EmailTomador>%s</ns1:EmailTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EmailTomador), input_name='EmailTomador')), eol_))
        if self.CodigoAtividade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CodigoAtividade>%s</ns1:CodigoAtividade>%s' % (self.gds_format_integer(self.CodigoAtividade, input_name='CodigoAtividade'), eol_))
        if self.AliquotaAtividade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaAtividade>%s</ns1:AliquotaAtividade>%s' % (self.gds_format_float(self.AliquotaAtividade, input_name='AliquotaAtividade'), eol_))
        if self.TipoRecolhimento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoRecolhimento>%s</ns1:TipoRecolhimento>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoRecolhimento), input_name='TipoRecolhimento')), eol_))
        if self.MunicipioPrestacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:MunicipioPrestacao>%s</ns1:MunicipioPrestacao>%s' % (self.gds_format_integer(self.MunicipioPrestacao, input_name='MunicipioPrestacao'), eol_))
        if self.MunicipioPrestacaoDescricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:MunicipioPrestacaoDescricao>%s</ns1:MunicipioPrestacaoDescricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MunicipioPrestacaoDescricao), input_name='MunicipioPrestacaoDescricao')), eol_))
        if self.Operacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Operacao>%s</ns1:Operacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Operacao), input_name='Operacao')), eol_))
        if self.Tributacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Tributacao>%s</ns1:Tributacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Tributacao), input_name='Tributacao')), eol_))
        if self.ValorPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorPIS>%s</ns1:ValorPIS>%s' % (self.gds_format_float(self.ValorPIS, input_name='ValorPIS'), eol_))
        if self.ValorCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorCOFINS>%s</ns1:ValorCOFINS>%s' % (self.gds_format_float(self.ValorCOFINS, input_name='ValorCOFINS'), eol_))
        if self.ValorINSS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorINSS>%s</ns1:ValorINSS>%s' % (self.gds_format_float(self.ValorINSS, input_name='ValorINSS'), eol_))
        if self.ValorIR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorIR>%s</ns1:ValorIR>%s' % (self.gds_format_float(self.ValorIR, input_name='ValorIR'), eol_))
        if self.ValorCSLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorCSLL>%s</ns1:ValorCSLL>%s' % (self.gds_format_float(self.ValorCSLL, input_name='ValorCSLL'), eol_))
        if self.AliquotaPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaPIS>%s</ns1:AliquotaPIS>%s' % (self.gds_format_float(self.AliquotaPIS, input_name='AliquotaPIS'), eol_))
        if self.AliquotaCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaCOFINS>%s</ns1:AliquotaCOFINS>%s' % (self.gds_format_float(self.AliquotaCOFINS, input_name='AliquotaCOFINS'), eol_))
        if self.AliquotaINSS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaINSS>%s</ns1:AliquotaINSS>%s' % (self.gds_format_float(self.AliquotaINSS, input_name='AliquotaINSS'), eol_))
        if self.AliquotaIR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaIR>%s</ns1:AliquotaIR>%s' % (self.gds_format_float(self.AliquotaIR, input_name='AliquotaIR'), eol_))
        if self.AliquotaCSLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaCSLL>%s</ns1:AliquotaCSLL>%s' % (self.gds_format_float(self.AliquotaCSLL, input_name='AliquotaCSLL'), eol_))
        if self.DescricaoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DescricaoRPS>%s</ns1:DescricaoRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DescricaoRPS), input_name='DescricaoRPS')), eol_))
        if self.DDDPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DDDPrestador>%s</ns1:DDDPrestador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DDDPrestador), input_name='DDDPrestador')), eol_))
        if self.TelefonePrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TelefonePrestador>%s</ns1:TelefonePrestador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TelefonePrestador), input_name='TelefonePrestador')), eol_))
        if self.DDDTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DDDTomador>%s</ns1:DDDTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DDDTomador), input_name='DDDTomador')), eol_))
        if self.TelefoneTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TelefoneTomador>%s</ns1:TelefoneTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TelefoneTomador), input_name='TelefoneTomador')), eol_))
        if self.MotCancelamento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:MotCancelamento>%s</ns1:MotCancelamento>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MotCancelamento), input_name='MotCancelamento')), eol_))
        if self.CPFCNPJIntermediario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CPFCNPJIntermediario>%s</ns1:CPFCNPJIntermediario>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPFCNPJIntermediario), input_name='CPFCNPJIntermediario')), eol_))
        if self.Deducoes is not None:
            self.Deducoes.export(outfile, level, namespace_, name_='Deducoes', pretty_print=pretty_print)
        if self.Itens is not None:
            self.Itens.export(outfile, level, namespace_, name_='Itens', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumeroNota':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNota')
            self.NumeroNota = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroNota)
        elif nodeName_ == 'DataProcessamento':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DataProcessamento = dval_
        elif nodeName_ == 'NumeroLote':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroLote')
            self.NumeroLote = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroLote)
        elif nodeName_ == 'CodigoVerificacao':
            CodigoVerificacao_ = child_.text
            CodigoVerificacao_ = self.gds_validate_string(CodigoVerificacao_, node, 'CodigoVerificacao')
            self.CodigoVerificacao = CodigoVerificacao_
            # validate type tpCodigoVerificacao
            self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
        elif nodeName_ == 'Assinatura':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Assinatura')
            else:
                bval_ = None
            self.Assinatura = bval_
            # validate type tpAssinatura
            self.validate_tpAssinatura(self.Assinatura)
        elif nodeName_ == 'InscricaoMunicipalPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipalPrestador')
            self.InscricaoMunicipalPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        elif nodeName_ == 'RazaoSocialPrestador':
            RazaoSocialPrestador_ = child_.text
            RazaoSocialPrestador_ = self.gds_validate_string(RazaoSocialPrestador_, node, 'RazaoSocialPrestador')
            self.RazaoSocialPrestador = RazaoSocialPrestador_
            # validate type tpRazaoSocialPrestador
            self.validate_tpRazaoSocialPrestador(self.RazaoSocialPrestador)
        elif nodeName_ == 'TipoRPS':
            TipoRPS_ = child_.text
            TipoRPS_ = self.gds_validate_string(TipoRPS_, node, 'TipoRPS')
            self.TipoRPS = TipoRPS_
            # validate type tpTipoRPS
            self.validate_tpTipoRPS(self.TipoRPS)
        elif nodeName_ == 'SerieRPS':
            SerieRPS_ = child_.text
            SerieRPS_ = self.gds_validate_string(SerieRPS_, node, 'SerieRPS')
            self.SerieRPS = SerieRPS_
            # validate type tpSerieRPS
            self.validate_tpSerieRPS(self.SerieRPS)
        elif nodeName_ == 'NumeroRPS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroRPS')
            self.NumeroRPS = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroRPS)
        elif nodeName_ == 'DataEmissaoRPS':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DataEmissaoRPS = dval_
            # validate type tpDataHora
            self.validate_tpDataHora(self.DataEmissaoRPS)
        elif nodeName_ == 'SituacaoRPS':
            SituacaoRPS_ = child_.text
            SituacaoRPS_ = self.gds_validate_string(SituacaoRPS_, node, 'SituacaoRPS')
            self.SituacaoRPS = SituacaoRPS_
            # validate type tpSituacaoRPS
            self.validate_tpSituacaoRPS(self.SituacaoRPS)
        elif nodeName_ == 'SerieRPSSubstituido':
            SerieRPSSubstituido_ = child_.text
            SerieRPSSubstituido_ = self.gds_validate_string(SerieRPSSubstituido_, node, 'SerieRPSSubstituido')
            self.SerieRPSSubstituido = SerieRPSSubstituido_
            # validate type tpSerieRPSSubstituido
            self.validate_tpSerieRPSSubstituido(self.SerieRPSSubstituido)
        elif nodeName_ == 'NumeroRPSSubstituido':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroRPSSubstituido')
            self.NumeroRPSSubstituido = ival_
            # validate type tpNumeroComZero
            self.validate_tpNumeroComZero(self.NumeroRPSSubstituido)
        elif nodeName_ == 'NumeroNFSeSubstituida':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNFSeSubstituida')
            self.NumeroNFSeSubstituida = ival_
            # validate type tpNumeroComZero
            self.validate_tpNumeroComZero(self.NumeroNFSeSubstituida)
        elif nodeName_ == 'DataEmissaoNFSeSubstituida':
            DataEmissaoNFSeSubstituida_ = child_.text
            DataEmissaoNFSeSubstituida_ = self.gds_validate_string(DataEmissaoNFSeSubstituida_, node, 'DataEmissaoNFSeSubstituida')
            self.DataEmissaoNFSeSubstituida = DataEmissaoNFSeSubstituida_
            # validate type tpDataHoraNulo
            self.validate_tpDataHoraNulo(self.DataEmissaoNFSeSubstituida)
        elif nodeName_ == 'SeriePrestacao':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SeriePrestacao')
            self.SeriePrestacao = ival_
            # validate type tpSeriePrestacao
            self.validate_tpSeriePrestacao(self.SeriePrestacao)
        elif nodeName_ == 'InscricaoMunicipalTomador':
            InscricaoMunicipalTomador_ = child_.text
            InscricaoMunicipalTomador_ = self.gds_validate_string(InscricaoMunicipalTomador_, node, 'InscricaoMunicipalTomador')
            self.InscricaoMunicipalTomador = InscricaoMunicipalTomador_
            # validate type tpInscricaoMunicipalNulo
            self.validate_tpInscricaoMunicipalNulo(self.InscricaoMunicipalTomador)
        elif nodeName_ == 'CPFCNPJTomador':
            CPFCNPJTomador_ = child_.text
            CPFCNPJTomador_ = self.gds_validate_string(CPFCNPJTomador_, node, 'CPFCNPJTomador')
            self.CPFCNPJTomador = CPFCNPJTomador_
            # validate type tpCPFCNPJ
            self.validate_tpCPFCNPJ(self.CPFCNPJTomador)
        elif nodeName_ == 'RazaoSocialTomador':
            RazaoSocialTomador_ = child_.text
            RazaoSocialTomador_ = self.gds_validate_string(RazaoSocialTomador_, node, 'RazaoSocialTomador')
            self.RazaoSocialTomador = RazaoSocialTomador_
            # validate type tpRazaoSocial
            self.validate_tpRazaoSocial(self.RazaoSocialTomador)
        elif nodeName_ == 'DocTomadorEstrangeiro':
            DocTomadorEstrangeiro_ = child_.text
            DocTomadorEstrangeiro_ = self.gds_validate_string(DocTomadorEstrangeiro_, node, 'DocTomadorEstrangeiro')
            self.DocTomadorEstrangeiro = DocTomadorEstrangeiro_
            # validate type tpDocTomadorEstrangeiro
            self.validate_tpDocTomadorEstrangeiro(self.DocTomadorEstrangeiro)
        elif nodeName_ == 'TipoLogradouroTomador':
            TipoLogradouroTomador_ = child_.text
            TipoLogradouroTomador_ = self.gds_validate_string(TipoLogradouroTomador_, node, 'TipoLogradouroTomador')
            self.TipoLogradouroTomador = TipoLogradouroTomador_
            # validate type tpTipoLogradouro
            self.validate_tpTipoLogradouro(self.TipoLogradouroTomador)
        elif nodeName_ == 'LogradouroTomador':
            LogradouroTomador_ = child_.text
            LogradouroTomador_ = self.gds_validate_string(LogradouroTomador_, node, 'LogradouroTomador')
            self.LogradouroTomador = LogradouroTomador_
            # validate type tpLogradouro
            self.validate_tpLogradouro(self.LogradouroTomador)
        elif nodeName_ == 'NumeroEnderecoTomador':
            NumeroEnderecoTomador_ = child_.text
            NumeroEnderecoTomador_ = self.gds_validate_string(NumeroEnderecoTomador_, node, 'NumeroEnderecoTomador')
            self.NumeroEnderecoTomador = NumeroEnderecoTomador_
            # validate type tpNumeroEndereco
            self.validate_tpNumeroEndereco(self.NumeroEnderecoTomador)
        elif nodeName_ == 'ComplementoEnderecoTomador':
            ComplementoEnderecoTomador_ = child_.text
            ComplementoEnderecoTomador_ = self.gds_validate_string(ComplementoEnderecoTomador_, node, 'ComplementoEnderecoTomador')
            self.ComplementoEnderecoTomador = ComplementoEnderecoTomador_
            # validate type tpComplementoEndereco
            self.validate_tpComplementoEndereco(self.ComplementoEnderecoTomador)
        elif nodeName_ == 'TipoBairroTomador':
            TipoBairroTomador_ = child_.text
            TipoBairroTomador_ = self.gds_validate_string(TipoBairroTomador_, node, 'TipoBairroTomador')
            self.TipoBairroTomador = TipoBairroTomador_
            # validate type tpTipoBairro
            self.validate_tpTipoBairro(self.TipoBairroTomador)
        elif nodeName_ == 'BairroTomador':
            BairroTomador_ = child_.text
            BairroTomador_ = self.gds_validate_string(BairroTomador_, node, 'BairroTomador')
            self.BairroTomador = BairroTomador_
            # validate type tpBairro
            self.validate_tpBairro(self.BairroTomador)
        elif nodeName_ == 'CidadeTomador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CidadeTomador')
            self.CidadeTomador = ival_
            # validate type tpCodCidade
            self.validate_tpCodCidade(self.CidadeTomador)
        elif nodeName_ == 'CidadeTomadorDescricao':
            CidadeTomadorDescricao_ = child_.text
            CidadeTomadorDescricao_ = self.gds_validate_string(CidadeTomadorDescricao_, node, 'CidadeTomadorDescricao')
            self.CidadeTomadorDescricao = CidadeTomadorDescricao_
            # validate type tpCidadeTomadorDescricao
            self.validate_tpCidadeTomadorDescricao(self.CidadeTomadorDescricao)
        elif nodeName_ == 'CEPTomador':
            CEPTomador_ = child_.text
            CEPTomador_ = self.gds_validate_string(CEPTomador_, node, 'CEPTomador')
            self.CEPTomador = CEPTomador_
            # validate type tpCEPNulo
            self.validate_tpCEPNulo(self.CEPTomador)
        elif nodeName_ == 'EmailTomador':
            EmailTomador_ = child_.text
            EmailTomador_ = self.gds_validate_string(EmailTomador_, node, 'EmailTomador')
            self.EmailTomador = EmailTomador_
            # validate type tpEmail
            self.validate_tpEmail(self.EmailTomador)
        elif nodeName_ == 'CodigoAtividade':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CodigoAtividade')
            self.CodigoAtividade = ival_
            # validate type tpCodigoAtividade
            self.validate_tpCodigoAtividade(self.CodigoAtividade)
        elif nodeName_ == 'AliquotaAtividade':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaAtividade')
            self.AliquotaAtividade = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaAtividade)
        elif nodeName_ == 'TipoRecolhimento':
            TipoRecolhimento_ = child_.text
            TipoRecolhimento_ = self.gds_validate_string(TipoRecolhimento_, node, 'TipoRecolhimento')
            self.TipoRecolhimento = TipoRecolhimento_
            # validate type tpTipoRecolhimento
            self.validate_tpTipoRecolhimento(self.TipoRecolhimento)
        elif nodeName_ == 'MunicipioPrestacao':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MunicipioPrestacao')
            self.MunicipioPrestacao = ival_
            # validate type tpCodCidade
            self.validate_tpCodCidade(self.MunicipioPrestacao)
        elif nodeName_ == 'MunicipioPrestacaoDescricao':
            MunicipioPrestacaoDescricao_ = child_.text
            MunicipioPrestacaoDescricao_ = self.gds_validate_string(MunicipioPrestacaoDescricao_, node, 'MunicipioPrestacaoDescricao')
            self.MunicipioPrestacaoDescricao = MunicipioPrestacaoDescricao_
            # validate type tpCidadeDescricao
            self.validate_tpCidadeDescricao(self.MunicipioPrestacaoDescricao)
        elif nodeName_ == 'Operacao':
            Operacao_ = child_.text
            Operacao_ = self.gds_validate_string(Operacao_, node, 'Operacao')
            self.Operacao = Operacao_
            # validate type tpOperacao
            self.validate_tpOperacao(self.Operacao)
        elif nodeName_ == 'Tributacao':
            Tributacao_ = child_.text
            Tributacao_ = self.gds_validate_string(Tributacao_, node, 'Tributacao')
            self.Tributacao = Tributacao_
            # validate type tpTributacao
            self.validate_tpTributacao(self.Tributacao)
        elif nodeName_ == 'ValorPIS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorPIS')
            self.ValorPIS = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorPIS)
        elif nodeName_ == 'ValorCOFINS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorCOFINS')
            self.ValorCOFINS = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorCOFINS)
        elif nodeName_ == 'ValorINSS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorINSS')
            self.ValorINSS = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorINSS)
        elif nodeName_ == 'ValorIR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorIR')
            self.ValorIR = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorIR)
        elif nodeName_ == 'ValorCSLL':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorCSLL')
            self.ValorCSLL = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorCSLL)
        elif nodeName_ == 'AliquotaPIS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaPIS')
            self.AliquotaPIS = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaPIS)
        elif nodeName_ == 'AliquotaCOFINS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaCOFINS')
            self.AliquotaCOFINS = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaCOFINS)
        elif nodeName_ == 'AliquotaINSS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaINSS')
            self.AliquotaINSS = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaINSS)
        elif nodeName_ == 'AliquotaIR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaIR')
            self.AliquotaIR = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaIR)
        elif nodeName_ == 'AliquotaCSLL':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaCSLL')
            self.AliquotaCSLL = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaCSLL)
        elif nodeName_ == 'DescricaoRPS':
            DescricaoRPS_ = child_.text
            DescricaoRPS_ = self.gds_validate_string(DescricaoRPS_, node, 'DescricaoRPS')
            self.DescricaoRPS = DescricaoRPS_
            # validate type tpDescricaoRPS
            self.validate_tpDescricaoRPS(self.DescricaoRPS)
        elif nodeName_ == 'DDDPrestador':
            DDDPrestador_ = child_.text
            DDDPrestador_ = self.gds_validate_string(DDDPrestador_, node, 'DDDPrestador')
            self.DDDPrestador = DDDPrestador_
            # validate type tpDDDNulo
            self.validate_tpDDDNulo(self.DDDPrestador)
        elif nodeName_ == 'TelefonePrestador':
            TelefonePrestador_ = child_.text
            TelefonePrestador_ = self.gds_validate_string(TelefonePrestador_, node, 'TelefonePrestador')
            self.TelefonePrestador = TelefonePrestador_
            # validate type tpFoneNulo
            self.validate_tpFoneNulo(self.TelefonePrestador)
        elif nodeName_ == 'DDDTomador':
            DDDTomador_ = child_.text
            DDDTomador_ = self.gds_validate_string(DDDTomador_, node, 'DDDTomador')
            self.DDDTomador = DDDTomador_
            # validate type tpDDDNulo
            self.validate_tpDDDNulo(self.DDDTomador)
        elif nodeName_ == 'TelefoneTomador':
            TelefoneTomador_ = child_.text
            TelefoneTomador_ = self.gds_validate_string(TelefoneTomador_, node, 'TelefoneTomador')
            self.TelefoneTomador = TelefoneTomador_
            # validate type tpFoneNulo
            self.validate_tpFoneNulo(self.TelefoneTomador)
        elif nodeName_ == 'MotCancelamento':
            MotCancelamento_ = child_.text
            MotCancelamento_ = self.gds_validate_string(MotCancelamento_, node, 'MotCancelamento')
            self.MotCancelamento = MotCancelamento_
            # validate type tpMotCancelamento
            self.validate_tpMotCancelamento(self.MotCancelamento)
        elif nodeName_ == 'CPFCNPJIntermediario':
            CPFCNPJIntermediario_ = child_.text
            CPFCNPJIntermediario_ = self.gds_validate_string(CPFCNPJIntermediario_, node, 'CPFCNPJIntermediario')
            self.CPFCNPJIntermediario = CPFCNPJIntermediario_
            # validate type tpCPFCNPJnulo
            self.validate_tpCPFCNPJnulo(self.CPFCNPJIntermediario)
        elif nodeName_ == 'Deducoes':
            obj_ = tpListaDeducoes.factory()
            obj_.build(child_)
            self.Deducoes = obj_
            obj_.original_tagname_ = 'Deducoes'
        elif nodeName_ == 'Itens':
            obj_ = tpListaItens.factory()
            obj_.build(child_)
            self.Itens = obj_
            obj_.original_tagname_ = 'Itens'
# end class tpNFSe


class tpRPS(GeneratedsSuper):
    """Tipo que representa um RPS."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, Assinatura=None, InscricaoMunicipalPrestador=None, RazaoSocialPrestador=None, TipoRPS=None, SerieRPS=None, NumeroRPS=None, DataEmissaoRPS=None, SituacaoRPS=None, SerieRPSSubstituido=None, NumeroRPSSubstituido=None, NumeroNFSeSubstituida=None, DataEmissaoNFSeSubstituida=None, SeriePrestacao=None, InscricaoMunicipalTomador=None, CPFCNPJTomador=None, RazaoSocialTomador=None, DocTomadorEstrangeiro=None, TipoLogradouroTomador=None, LogradouroTomador=None, NumeroEnderecoTomador=None, ComplementoEnderecoTomador=None, TipoBairroTomador=None, BairroTomador=None, CidadeTomador=None, CidadeTomadorDescricao=None, CEPTomador=None, EmailTomador=None, CodigoAtividade=None, AliquotaAtividade=None, TipoRecolhimento=None, MunicipioPrestacao=None, MunicipioPrestacaoDescricao=None, Operacao=None, Tributacao=None, ValorPIS=None, ValorCOFINS=None, ValorINSS=None, ValorIR=None, ValorCSLL=None, AliquotaPIS=None, AliquotaCOFINS=None, AliquotaINSS=None, AliquotaIR=None, AliquotaCSLL=None, DescricaoRPS=None, DDDPrestador=None, TelefonePrestador=None, DDDTomador=None, TelefoneTomador=None, MotCancelamento=None, CPFCNPJIntermediario=None, Deducoes=None, Itens=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.Assinatura = Assinatura
        self.validate_tpAssinatura(self.Assinatura)
        self.InscricaoMunicipalPrestador = InscricaoMunicipalPrestador
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        self.RazaoSocialPrestador = RazaoSocialPrestador
        self.validate_tpRazaoSocialPrestador(self.RazaoSocialPrestador)
        self.TipoRPS = TipoRPS
        self.validate_tpTipoRPS(self.TipoRPS)
        self.SerieRPS = SerieRPS
        self.validate_tpSerieRPS(self.SerieRPS)
        self.NumeroRPS = NumeroRPS
        self.validate_tpNumero(self.NumeroRPS)
        if isinstance(DataEmissaoRPS, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataEmissaoRPS, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DataEmissaoRPS
        self.DataEmissaoRPS = initvalue_
        self.SituacaoRPS = SituacaoRPS
        self.validate_tpSituacaoRPS(self.SituacaoRPS)
        self.SerieRPSSubstituido = SerieRPSSubstituido
        self.validate_tpSerieRPSSubstituido(self.SerieRPSSubstituido)
        self.NumeroRPSSubstituido = NumeroRPSSubstituido
        self.validate_tpNumeroComZero(self.NumeroRPSSubstituido)
        self.NumeroNFSeSubstituida = NumeroNFSeSubstituida
        self.validate_tpNumeroComZero(self.NumeroNFSeSubstituida)
        self.DataEmissaoNFSeSubstituida = DataEmissaoNFSeSubstituida
        self.validate_tpDataNulo(self.DataEmissaoNFSeSubstituida)
        self.SeriePrestacao = SeriePrestacao
        self.validate_tpSeriePrestacao(self.SeriePrestacao)
        self.InscricaoMunicipalTomador = InscricaoMunicipalTomador
        self.validate_tpInscricaoMunicipalNulo(self.InscricaoMunicipalTomador)
        self.CPFCNPJTomador = CPFCNPJTomador
        self.validate_tpCPFCNPJ(self.CPFCNPJTomador)
        self.RazaoSocialTomador = RazaoSocialTomador
        self.validate_tpRazaoSocial(self.RazaoSocialTomador)
        self.DocTomadorEstrangeiro = DocTomadorEstrangeiro
        self.validate_tpDocTomadorEstrangeiro(self.DocTomadorEstrangeiro)
        self.TipoLogradouroTomador = TipoLogradouroTomador
        self.validate_tpTipoLogradouro(self.TipoLogradouroTomador)
        self.LogradouroTomador = LogradouroTomador
        self.validate_tpLogradouro(self.LogradouroTomador)
        self.NumeroEnderecoTomador = NumeroEnderecoTomador
        self.validate_tpNumeroEndereco(self.NumeroEnderecoTomador)
        self.ComplementoEnderecoTomador = ComplementoEnderecoTomador
        self.validate_tpComplementoEndereco(self.ComplementoEnderecoTomador)
        self.TipoBairroTomador = TipoBairroTomador
        self.validate_tpTipoBairro(self.TipoBairroTomador)
        self.BairroTomador = BairroTomador
        self.validate_tpBairro(self.BairroTomador)
        self.CidadeTomador = CidadeTomador
        self.validate_tpCodCidade(self.CidadeTomador)
        self.CidadeTomadorDescricao = CidadeTomadorDescricao
        self.validate_tpCidadeTomadorDescricao(self.CidadeTomadorDescricao)
        self.CEPTomador = CEPTomador
        self.validate_tpCEP(self.CEPTomador)
        self.EmailTomador = EmailTomador
        self.validate_tpEmail(self.EmailTomador)
        self.CodigoAtividade = CodigoAtividade
        self.validate_tpCodigoAtividade(self.CodigoAtividade)
        self.AliquotaAtividade = AliquotaAtividade
        self.validate_tpAliquota(self.AliquotaAtividade)
        self.TipoRecolhimento = TipoRecolhimento
        self.validate_tpTipoRecolhimento(self.TipoRecolhimento)
        self.MunicipioPrestacao = MunicipioPrestacao
        self.validate_tpCodCidade(self.MunicipioPrestacao)
        self.MunicipioPrestacaoDescricao = MunicipioPrestacaoDescricao
        self.validate_tpCidadeDescricao(self.MunicipioPrestacaoDescricao)
        self.Operacao = Operacao
        self.validate_tpOperacao(self.Operacao)
        self.Tributacao = Tributacao
        self.validate_tpTributacao(self.Tributacao)
        self.ValorPIS = ValorPIS
        self.validate_tpValor(self.ValorPIS)
        self.ValorCOFINS = ValorCOFINS
        self.validate_tpValor(self.ValorCOFINS)
        self.ValorINSS = ValorINSS
        self.validate_tpValor(self.ValorINSS)
        self.ValorIR = ValorIR
        self.validate_tpValor(self.ValorIR)
        self.ValorCSLL = ValorCSLL
        self.validate_tpValor(self.ValorCSLL)
        self.AliquotaPIS = AliquotaPIS
        self.validate_tpAliquota(self.AliquotaPIS)
        self.AliquotaCOFINS = AliquotaCOFINS
        self.validate_tpAliquota(self.AliquotaCOFINS)
        self.AliquotaINSS = AliquotaINSS
        self.validate_tpAliquota(self.AliquotaINSS)
        self.AliquotaIR = AliquotaIR
        self.validate_tpAliquota(self.AliquotaIR)
        self.AliquotaCSLL = AliquotaCSLL
        self.validate_tpAliquota(self.AliquotaCSLL)
        self.DescricaoRPS = DescricaoRPS
        self.validate_tpDescricaoRPS(self.DescricaoRPS)
        self.DDDPrestador = DDDPrestador
        self.validate_tpDDDNulo(self.DDDPrestador)
        self.TelefonePrestador = TelefonePrestador
        self.validate_tpFoneNulo(self.TelefonePrestador)
        self.DDDTomador = DDDTomador
        self.validate_tpDDDNulo(self.DDDTomador)
        self.TelefoneTomador = TelefoneTomador
        self.validate_tpFoneNulo(self.TelefoneTomador)
        self.MotCancelamento = MotCancelamento
        self.validate_tpMotCancelamento(self.MotCancelamento)
        self.CPFCNPJIntermediario = CPFCNPJIntermediario
        self.validate_tpCPFCNPJnulo(self.CPFCNPJIntermediario)
        self.Deducoes = Deducoes
        self.Itens = Itens
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpRPS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpRPS.subclass:
            return tpRPS.subclass(*args_, **kwargs_)
        else:
            return tpRPS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpAssinatura(self, value):
        # Validate type tpAssinatura, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{6,11}$']]
    def validate_tpRazaoSocialPrestador(self, value):
        # Validate type tpRazaoSocialPrestador, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpRazaoSocialPrestador' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpRazaoSocialPrestador' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoRPS(self, value):
        # Validate type tpTipoRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['RPS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTipoRPS' % {"value" : value.encode("utf-8")} )
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpSerieRPS(self, value):
        # Validate type tpSerieRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpSerieRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpNumero(self, value):
        # Validate type tpNumero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumero_patterns_, ))
    validate_tpNumero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpSituacaoRPS(self, value):
        # Validate type tpSituacaoRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['N', 'C']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpSituacaoRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpSerieRPSSubstituido(self, value):
        # Validate type tpSerieRPSSubstituido, a restriction on None.
        pass
    def validate_tpNumeroComZero(self, value):
        # Validate type tpNumeroComZero, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpNumeroComZero' % {"value" : value} )
            if value > 2147483647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumeroComZero' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpNumeroComZero_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpNumeroComZero_patterns_, ))
    validate_tpNumeroComZero_patterns_ = [['^[0-9]{1,12}$']]
    def validate_tpDataNulo(self, value):
        # Validate type tpDataNulo, a restriction on None.
        pass
    def validate_tpSeriePrestacao(self, value):
        # Validate type tpSeriePrestacao, a restriction on xs:byte.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpSeriePrestacao' % {"value" : value} )
            if value > 99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpSeriePrestacao' % {"value" : value} )
    def validate_tpInscricaoMunicipalNulo(self, value):
        # Validate type tpInscricaoMunicipalNulo, a restriction on None.
        pass
    def validate_tpCPFCNPJ(self, value):
        # Validate type tpCPFCNPJ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCPFCNPJ_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCPFCNPJ_patterns_, ))
    validate_tpCPFCNPJ_patterns_ = [['^[0-9]{11}$|^[0-9]{14}$']]
    def validate_tpRazaoSocial(self, value):
        # Validate type tpRazaoSocial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
    def validate_tpDocTomadorEstrangeiro(self, value):
        # Validate type tpDocTomadorEstrangeiro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDocTomadorEstrangeiro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpDocTomadorEstrangeiro' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoLogradouro(self, value):
        # Validate type tpTipoLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
    def validate_tpLogradouro(self, value):
        # Validate type tpLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
    def validate_tpNumeroEndereco(self, value):
        # Validate type tpNumeroEndereco, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpNumeroEndereco' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpNumeroEndereco' % {"value" : value.encode("utf-8")} )
    def validate_tpComplementoEndereco(self, value):
        # Validate type tpComplementoEndereco, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpComplementoEndereco' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpComplementoEndereco' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoBairro(self, value):
        # Validate type tpTipoBairro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoBairro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoBairro' % {"value" : value.encode("utf-8")} )
    def validate_tpBairro(self, value):
        # Validate type tpBairro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
    def validate_tpCodCidade(self, value):
        # Validate type tpCodCidade, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpCodCidade' % {"value" : value} )
    def validate_tpCidadeTomadorDescricao(self, value):
        # Validate type tpCidadeTomadorDescricao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCidadeTomadorDescricao' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCidadeTomadorDescricao' % {"value" : value.encode("utf-8")} )
    def validate_tpCEP(self, value):
        # Validate type tpCEP, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCEP_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCEP_patterns_, ))
    validate_tpCEP_patterns_ = [['^[0-9]{0,8}$']]
    def validate_tpEmail(self, value):
        # Validate type tpEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpEmail' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpEmail' % {"value" : value.encode("utf-8")} )
    def validate_tpCodigoAtividade(self, value):
        # Validate type tpCodigoAtividade, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCodigoAtividade_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCodigoAtividade_patterns_, ))
    validate_tpCodigoAtividade_patterns_ = [['^[0-9]{9}$']]
    def validate_tpAliquota(self, value):
        # Validate type tpAliquota, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpAliquota' % {"value" : value} )
            if len(str(value)) >= 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpAliquota' % {"value" : value} )
    def validate_tpTipoRecolhimento(self, value):
        # Validate type tpTipoRecolhimento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'R']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTipoRecolhimento' % {"value" : value.encode("utf-8")} )
    def validate_tpCidadeDescricao(self, value):
        # Validate type tpCidadeDescricao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCidadeDescricao' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCidadeDescricao' % {"value" : value.encode("utf-8")} )
    def validate_tpOperacao(self, value):
        # Validate type tpOperacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'B', 'C', 'D', 'J']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpOperacao' % {"value" : value.encode("utf-8")} )
    def validate_tpTributacao(self, value):
        # Validate type tpTributacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['C', 'F', 'K', 'E', 'T', 'H', 'G', 'N', 'M']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTributacao' % {"value" : value.encode("utf-8")} )
    def validate_tpValor(self, value):
        # Validate type tpValor, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpValor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpValor_patterns_, ))
    validate_tpValor_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{0,2})?$']]
    def validate_tpDescricaoRPS(self, value):
        # Validate type tpDescricaoRPS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 1500:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDescricaoRPS' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpDescricaoRPS' % {"value" : value.encode("utf-8")} )
    def validate_tpDDDNulo(self, value):
        # Validate type tpDDDNulo, a restriction on None.
        pass
    def validate_tpFoneNulo(self, value):
        # Validate type tpFoneNulo, a restriction on None.
        pass
    def validate_tpMotCancelamento(self, value):
        # Validate type tpMotCancelamento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpMotCancelamento' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpMotCancelamento' % {"value" : value.encode("utf-8")} )
    def validate_tpCPFCNPJnulo(self, value):
        # Validate type tpCPFCNPJnulo, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Assinatura is not None or
            self.InscricaoMunicipalPrestador is not None or
            self.RazaoSocialPrestador is not None or
            self.TipoRPS is not None or
            self.SerieRPS is not None or
            self.NumeroRPS is not None or
            self.DataEmissaoRPS is not None or
            self.SituacaoRPS is not None or
            self.SerieRPSSubstituido is not None or
            self.NumeroRPSSubstituido is not None or
            self.NumeroNFSeSubstituida is not None or
            self.DataEmissaoNFSeSubstituida is not None or
            self.SeriePrestacao is not None or
            self.InscricaoMunicipalTomador is not None or
            self.CPFCNPJTomador is not None or
            self.RazaoSocialTomador is not None or
            self.DocTomadorEstrangeiro is not None or
            self.TipoLogradouroTomador is not None or
            self.LogradouroTomador is not None or
            self.NumeroEnderecoTomador is not None or
            self.ComplementoEnderecoTomador is not None or
            self.TipoBairroTomador is not None or
            self.BairroTomador is not None or
            self.CidadeTomador is not None or
            self.CidadeTomadorDescricao is not None or
            self.CEPTomador is not None or
            self.EmailTomador is not None or
            self.CodigoAtividade is not None or
            self.AliquotaAtividade is not None or
            self.TipoRecolhimento is not None or
            self.MunicipioPrestacao is not None or
            self.MunicipioPrestacaoDescricao is not None or
            self.Operacao is not None or
            self.Tributacao is not None or
            self.ValorPIS is not None or
            self.ValorCOFINS is not None or
            self.ValorINSS is not None or
            self.ValorIR is not None or
            self.ValorCSLL is not None or
            self.AliquotaPIS is not None or
            self.AliquotaCOFINS is not None or
            self.AliquotaINSS is not None or
            self.AliquotaIR is not None or
            self.AliquotaCSLL is not None or
            self.DescricaoRPS is not None or
            self.DDDPrestador is not None or
            self.TelefonePrestador is not None or
            self.DDDTomador is not None or
            self.TelefoneTomador is not None or
            self.MotCancelamento is not None or
            self.CPFCNPJIntermediario is not None or
            self.Deducoes is not None or
            self.Itens is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='tpRPS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpRPS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpRPS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='tpRPS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='tpRPS'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='tpRPS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Assinatura is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Assinatura>%s</ns1:Assinatura>%s' % (self.gds_format_base64(self.Assinatura, input_name='Assinatura'), eol_))
        if self.InscricaoMunicipalPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoMunicipalPrestador>%s</ns1:InscricaoMunicipalPrestador>%s' % (self.gds_format_integer(self.InscricaoMunicipalPrestador, input_name='InscricaoMunicipalPrestador'), eol_))
        if self.RazaoSocialPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:RazaoSocialPrestador>%s</ns1:RazaoSocialPrestador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RazaoSocialPrestador), input_name='RazaoSocialPrestador')), eol_))
        if self.TipoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoRPS>%s</ns1:TipoRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoRPS), input_name='TipoRPS')), eol_))
        if self.SerieRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SerieRPS>%s</ns1:SerieRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SerieRPS), input_name='SerieRPS')), eol_))
        if self.NumeroRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroRPS>%s</ns1:NumeroRPS>%s' % (self.gds_format_integer(self.NumeroRPS, input_name='NumeroRPS'), eol_))
        if self.DataEmissaoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DataEmissaoRPS>%s</ns1:DataEmissaoRPS>%s' % (self.gds_format_datetime(self.DataEmissaoRPS, input_name='DataEmissaoRPS'), eol_))
        if self.SituacaoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SituacaoRPS>%s</ns1:SituacaoRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SituacaoRPS), input_name='SituacaoRPS')), eol_))
        if self.SerieRPSSubstituido is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SerieRPSSubstituido>%s</ns1:SerieRPSSubstituido>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SerieRPSSubstituido), input_name='SerieRPSSubstituido')), eol_))
        if self.NumeroRPSSubstituido is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroRPSSubstituido>%s</ns1:NumeroRPSSubstituido>%s' % (self.gds_format_integer(self.NumeroRPSSubstituido, input_name='NumeroRPSSubstituido'), eol_))
        if self.NumeroNFSeSubstituida is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroNFSeSubstituida>%s</ns1:NumeroNFSeSubstituida>%s' % (self.gds_format_integer(self.NumeroNFSeSubstituida, input_name='NumeroNFSeSubstituida'), eol_))
        if self.DataEmissaoNFSeSubstituida is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DataEmissaoNFSeSubstituida>%s</ns1:DataEmissaoNFSeSubstituida>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataEmissaoNFSeSubstituida), input_name='DataEmissaoNFSeSubstituida')), eol_))
        if self.SeriePrestacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:SeriePrestacao>%s</ns1:SeriePrestacao>%s' % (self.gds_format_integer(self.SeriePrestacao, input_name='SeriePrestacao'), eol_))
        if self.InscricaoMunicipalTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:InscricaoMunicipalTomador>%s</ns1:InscricaoMunicipalTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.InscricaoMunicipalTomador), input_name='InscricaoMunicipalTomador')), eol_))
        if self.CPFCNPJTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CPFCNPJTomador>%s</ns1:CPFCNPJTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPFCNPJTomador), input_name='CPFCNPJTomador')), eol_))
        if self.RazaoSocialTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:RazaoSocialTomador>%s</ns1:RazaoSocialTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RazaoSocialTomador), input_name='RazaoSocialTomador')), eol_))
        if self.DocTomadorEstrangeiro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DocTomadorEstrangeiro>%s</ns1:DocTomadorEstrangeiro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocTomadorEstrangeiro), input_name='DocTomadorEstrangeiro')), eol_))
        if self.TipoLogradouroTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoLogradouroTomador>%s</ns1:TipoLogradouroTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoLogradouroTomador), input_name='TipoLogradouroTomador')), eol_))
        if self.LogradouroTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:LogradouroTomador>%s</ns1:LogradouroTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LogradouroTomador), input_name='LogradouroTomador')), eol_))
        if self.NumeroEnderecoTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:NumeroEnderecoTomador>%s</ns1:NumeroEnderecoTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NumeroEnderecoTomador), input_name='NumeroEnderecoTomador')), eol_))
        if self.ComplementoEnderecoTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ComplementoEnderecoTomador>%s</ns1:ComplementoEnderecoTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ComplementoEnderecoTomador), input_name='ComplementoEnderecoTomador')), eol_))
        if self.TipoBairroTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoBairroTomador>%s</ns1:TipoBairroTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoBairroTomador), input_name='TipoBairroTomador')), eol_))
        if self.BairroTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:BairroTomador>%s</ns1:BairroTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BairroTomador), input_name='BairroTomador')), eol_))
        if self.CidadeTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CidadeTomador>%s</ns1:CidadeTomador>%s' % (self.gds_format_integer(self.CidadeTomador, input_name='CidadeTomador'), eol_))
        if self.CidadeTomadorDescricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CidadeTomadorDescricao>%s</ns1:CidadeTomadorDescricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CidadeTomadorDescricao), input_name='CidadeTomadorDescricao')), eol_))
        if self.CEPTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CEPTomador>%s</ns1:CEPTomador>%s' % (self.gds_format_integer(self.CEPTomador, input_name='CEPTomador'), eol_))
        if self.EmailTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:EmailTomador>%s</ns1:EmailTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EmailTomador), input_name='EmailTomador')), eol_))
        if self.CodigoAtividade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CodigoAtividade>%s</ns1:CodigoAtividade>%s' % (self.gds_format_integer(self.CodigoAtividade, input_name='CodigoAtividade'), eol_))
        if self.AliquotaAtividade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaAtividade>%s</ns1:AliquotaAtividade>%s' % (self.gds_format_float(self.AliquotaAtividade, input_name='AliquotaAtividade'), eol_))
        if self.TipoRecolhimento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TipoRecolhimento>%s</ns1:TipoRecolhimento>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoRecolhimento), input_name='TipoRecolhimento')), eol_))
        if self.MunicipioPrestacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:MunicipioPrestacao>%s</ns1:MunicipioPrestacao>%s' % (self.gds_format_integer(self.MunicipioPrestacao, input_name='MunicipioPrestacao'), eol_))
        if self.MunicipioPrestacaoDescricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:MunicipioPrestacaoDescricao>%s</ns1:MunicipioPrestacaoDescricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MunicipioPrestacaoDescricao), input_name='MunicipioPrestacaoDescricao')), eol_))
        if self.Operacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Operacao>%s</ns1:Operacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Operacao), input_name='Operacao')), eol_))
        if self.Tributacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:Tributacao>%s</ns1:Tributacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Tributacao), input_name='Tributacao')), eol_))
        if self.ValorPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorPIS>%s</ns1:ValorPIS>%s' % (self.gds_format_float(self.ValorPIS, input_name='ValorPIS'), eol_))
        if self.ValorCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorCOFINS>%s</ns1:ValorCOFINS>%s' % (self.gds_format_float(self.ValorCOFINS, input_name='ValorCOFINS'), eol_))
        if self.ValorINSS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorINSS>%s</ns1:ValorINSS>%s' % (self.gds_format_float(self.ValorINSS, input_name='ValorINSS'), eol_))
        if self.ValorIR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorIR>%s</ns1:ValorIR>%s' % (self.gds_format_float(self.ValorIR, input_name='ValorIR'), eol_))
        if self.ValorCSLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:ValorCSLL>%s</ns1:ValorCSLL>%s' % (self.gds_format_float(self.ValorCSLL, input_name='ValorCSLL'), eol_))
        if self.AliquotaPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaPIS>%s</ns1:AliquotaPIS>%s' % (self.gds_format_float(self.AliquotaPIS, input_name='AliquotaPIS'), eol_))
        if self.AliquotaCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaCOFINS>%s</ns1:AliquotaCOFINS>%s' % (self.gds_format_float(self.AliquotaCOFINS, input_name='AliquotaCOFINS'), eol_))
        if self.AliquotaINSS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaINSS>%s</ns1:AliquotaINSS>%s' % (self.gds_format_float(self.AliquotaINSS, input_name='AliquotaINSS'), eol_))
        if self.AliquotaIR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaIR>%s</ns1:AliquotaIR>%s' % (self.gds_format_float(self.AliquotaIR, input_name='AliquotaIR'), eol_))
        if self.AliquotaCSLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:AliquotaCSLL>%s</ns1:AliquotaCSLL>%s' % (self.gds_format_float(self.AliquotaCSLL, input_name='AliquotaCSLL'), eol_))
        if self.DescricaoRPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DescricaoRPS>%s</ns1:DescricaoRPS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DescricaoRPS), input_name='DescricaoRPS')), eol_))
        if self.DDDPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DDDPrestador>%s</ns1:DDDPrestador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DDDPrestador), input_name='DDDPrestador')), eol_))
        if self.TelefonePrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TelefonePrestador>%s</ns1:TelefonePrestador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TelefonePrestador), input_name='TelefonePrestador')), eol_))
        if self.DDDTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DDDTomador>%s</ns1:DDDTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DDDTomador), input_name='DDDTomador')), eol_))
        if self.TelefoneTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:TelefoneTomador>%s</ns1:TelefoneTomador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TelefoneTomador), input_name='TelefoneTomador')), eol_))
        if self.MotCancelamento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:MotCancelamento>%s</ns1:MotCancelamento>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MotCancelamento), input_name='MotCancelamento')), eol_))
        if self.CPFCNPJIntermediario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:CPFCNPJIntermediario>%s</ns1:CPFCNPJIntermediario>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPFCNPJIntermediario), input_name='CPFCNPJIntermediario')), eol_))
        if self.Deducoes is not None:
            self.Deducoes.export(outfile, level, namespace_, name_='Deducoes', pretty_print=pretty_print)
        if self.Itens is not None:
            self.Itens.export(outfile, level, namespace_, name_='Itens', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Assinatura':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Assinatura')
            else:
                bval_ = None
            self.Assinatura = bval_
            # validate type tpAssinatura
            self.validate_tpAssinatura(self.Assinatura)
        elif nodeName_ == 'InscricaoMunicipalPrestador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipalPrestador')
            self.InscricaoMunicipalPrestador = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipalPrestador)
        elif nodeName_ == 'RazaoSocialPrestador':
            RazaoSocialPrestador_ = child_.text
            RazaoSocialPrestador_ = self.gds_validate_string(RazaoSocialPrestador_, node, 'RazaoSocialPrestador')
            self.RazaoSocialPrestador = RazaoSocialPrestador_
            # validate type tpRazaoSocialPrestador
            self.validate_tpRazaoSocialPrestador(self.RazaoSocialPrestador)
        elif nodeName_ == 'TipoRPS':
            TipoRPS_ = child_.text
            TipoRPS_ = self.gds_validate_string(TipoRPS_, node, 'TipoRPS')
            self.TipoRPS = TipoRPS_
            # validate type tpTipoRPS
            self.validate_tpTipoRPS(self.TipoRPS)
        elif nodeName_ == 'SerieRPS':
            SerieRPS_ = child_.text
            SerieRPS_ = self.gds_validate_string(SerieRPS_, node, 'SerieRPS')
            self.SerieRPS = SerieRPS_
            # validate type tpSerieRPS
            self.validate_tpSerieRPS(self.SerieRPS)
        elif nodeName_ == 'NumeroRPS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroRPS')
            self.NumeroRPS = ival_
            # validate type tpNumero
            self.validate_tpNumero(self.NumeroRPS)
        elif nodeName_ == 'DataEmissaoRPS':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DataEmissaoRPS = dval_
        elif nodeName_ == 'SituacaoRPS':
            SituacaoRPS_ = child_.text
            SituacaoRPS_ = self.gds_validate_string(SituacaoRPS_, node, 'SituacaoRPS')
            self.SituacaoRPS = SituacaoRPS_
            # validate type tpSituacaoRPS
            self.validate_tpSituacaoRPS(self.SituacaoRPS)
        elif nodeName_ == 'SerieRPSSubstituido':
            SerieRPSSubstituido_ = child_.text
            SerieRPSSubstituido_ = self.gds_validate_string(SerieRPSSubstituido_, node, 'SerieRPSSubstituido')
            self.SerieRPSSubstituido = SerieRPSSubstituido_
            # validate type tpSerieRPSSubstituido
            self.validate_tpSerieRPSSubstituido(self.SerieRPSSubstituido)
        elif nodeName_ == 'NumeroRPSSubstituido':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroRPSSubstituido')
            self.NumeroRPSSubstituido = ival_
            # validate type tpNumeroComZero
            self.validate_tpNumeroComZero(self.NumeroRPSSubstituido)
        elif nodeName_ == 'NumeroNFSeSubstituida':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNFSeSubstituida')
            self.NumeroNFSeSubstituida = ival_
            # validate type tpNumeroComZero
            self.validate_tpNumeroComZero(self.NumeroNFSeSubstituida)
        elif nodeName_ == 'DataEmissaoNFSeSubstituida':
            DataEmissaoNFSeSubstituida_ = child_.text
            DataEmissaoNFSeSubstituida_ = self.gds_validate_string(DataEmissaoNFSeSubstituida_, node, 'DataEmissaoNFSeSubstituida')
            self.DataEmissaoNFSeSubstituida = DataEmissaoNFSeSubstituida_
            # validate type tpDataNulo
            self.validate_tpDataNulo(self.DataEmissaoNFSeSubstituida)
        elif nodeName_ == 'SeriePrestacao':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SeriePrestacao')
            self.SeriePrestacao = ival_
            # validate type tpSeriePrestacao
            self.validate_tpSeriePrestacao(self.SeriePrestacao)
        elif nodeName_ == 'InscricaoMunicipalTomador':
            InscricaoMunicipalTomador_ = child_.text
            InscricaoMunicipalTomador_ = self.gds_validate_string(InscricaoMunicipalTomador_, node, 'InscricaoMunicipalTomador')
            self.InscricaoMunicipalTomador = InscricaoMunicipalTomador_
            # validate type tpInscricaoMunicipalNulo
            self.validate_tpInscricaoMunicipalNulo(self.InscricaoMunicipalTomador)
        elif nodeName_ == 'CPFCNPJTomador':
            CPFCNPJTomador_ = child_.text
            CPFCNPJTomador_ = self.gds_validate_string(CPFCNPJTomador_, node, 'CPFCNPJTomador')
            self.CPFCNPJTomador = CPFCNPJTomador_
            # validate type tpCPFCNPJ
            self.validate_tpCPFCNPJ(self.CPFCNPJTomador)
        elif nodeName_ == 'RazaoSocialTomador':
            RazaoSocialTomador_ = child_.text
            RazaoSocialTomador_ = self.gds_validate_string(RazaoSocialTomador_, node, 'RazaoSocialTomador')
            self.RazaoSocialTomador = RazaoSocialTomador_
            # validate type tpRazaoSocial
            self.validate_tpRazaoSocial(self.RazaoSocialTomador)
        elif nodeName_ == 'DocTomadorEstrangeiro':
            DocTomadorEstrangeiro_ = child_.text
            DocTomadorEstrangeiro_ = self.gds_validate_string(DocTomadorEstrangeiro_, node, 'DocTomadorEstrangeiro')
            self.DocTomadorEstrangeiro = DocTomadorEstrangeiro_
            # validate type tpDocTomadorEstrangeiro
            self.validate_tpDocTomadorEstrangeiro(self.DocTomadorEstrangeiro)
        elif nodeName_ == 'TipoLogradouroTomador':
            TipoLogradouroTomador_ = child_.text
            TipoLogradouroTomador_ = self.gds_validate_string(TipoLogradouroTomador_, node, 'TipoLogradouroTomador')
            self.TipoLogradouroTomador = TipoLogradouroTomador_
            # validate type tpTipoLogradouro
            self.validate_tpTipoLogradouro(self.TipoLogradouroTomador)
        elif nodeName_ == 'LogradouroTomador':
            LogradouroTomador_ = child_.text
            LogradouroTomador_ = self.gds_validate_string(LogradouroTomador_, node, 'LogradouroTomador')
            self.LogradouroTomador = LogradouroTomador_
            # validate type tpLogradouro
            self.validate_tpLogradouro(self.LogradouroTomador)
        elif nodeName_ == 'NumeroEnderecoTomador':
            NumeroEnderecoTomador_ = child_.text
            NumeroEnderecoTomador_ = self.gds_validate_string(NumeroEnderecoTomador_, node, 'NumeroEnderecoTomador')
            self.NumeroEnderecoTomador = NumeroEnderecoTomador_
            # validate type tpNumeroEndereco
            self.validate_tpNumeroEndereco(self.NumeroEnderecoTomador)
        elif nodeName_ == 'ComplementoEnderecoTomador':
            ComplementoEnderecoTomador_ = child_.text
            ComplementoEnderecoTomador_ = self.gds_validate_string(ComplementoEnderecoTomador_, node, 'ComplementoEnderecoTomador')
            self.ComplementoEnderecoTomador = ComplementoEnderecoTomador_
            # validate type tpComplementoEndereco
            self.validate_tpComplementoEndereco(self.ComplementoEnderecoTomador)
        elif nodeName_ == 'TipoBairroTomador':
            TipoBairroTomador_ = child_.text
            TipoBairroTomador_ = self.gds_validate_string(TipoBairroTomador_, node, 'TipoBairroTomador')
            self.TipoBairroTomador = TipoBairroTomador_
            # validate type tpTipoBairro
            self.validate_tpTipoBairro(self.TipoBairroTomador)
        elif nodeName_ == 'BairroTomador':
            BairroTomador_ = child_.text
            BairroTomador_ = self.gds_validate_string(BairroTomador_, node, 'BairroTomador')
            self.BairroTomador = BairroTomador_
            # validate type tpBairro
            self.validate_tpBairro(self.BairroTomador)
        elif nodeName_ == 'CidadeTomador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CidadeTomador')
            self.CidadeTomador = ival_
            # validate type tpCodCidade
            self.validate_tpCodCidade(self.CidadeTomador)
        elif nodeName_ == 'CidadeTomadorDescricao':
            CidadeTomadorDescricao_ = child_.text
            CidadeTomadorDescricao_ = self.gds_validate_string(CidadeTomadorDescricao_, node, 'CidadeTomadorDescricao')
            self.CidadeTomadorDescricao = CidadeTomadorDescricao_
            # validate type tpCidadeTomadorDescricao
            self.validate_tpCidadeTomadorDescricao(self.CidadeTomadorDescricao)
        elif nodeName_ == 'CEPTomador':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CEPTomador')
            self.CEPTomador = ival_
            # validate type tpCEP
            self.validate_tpCEP(self.CEPTomador)
        elif nodeName_ == 'EmailTomador':
            EmailTomador_ = child_.text
            EmailTomador_ = self.gds_validate_string(EmailTomador_, node, 'EmailTomador')
            self.EmailTomador = EmailTomador_
            # validate type tpEmail
            self.validate_tpEmail(self.EmailTomador)
        elif nodeName_ == 'CodigoAtividade':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CodigoAtividade')
            self.CodigoAtividade = ival_
            # validate type tpCodigoAtividade
            self.validate_tpCodigoAtividade(self.CodigoAtividade)
        elif nodeName_ == 'AliquotaAtividade':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaAtividade')
            self.AliquotaAtividade = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaAtividade)
        elif nodeName_ == 'TipoRecolhimento':
            TipoRecolhimento_ = child_.text
            TipoRecolhimento_ = self.gds_validate_string(TipoRecolhimento_, node, 'TipoRecolhimento')
            self.TipoRecolhimento = TipoRecolhimento_
            # validate type tpTipoRecolhimento
            self.validate_tpTipoRecolhimento(self.TipoRecolhimento)
        elif nodeName_ == 'MunicipioPrestacao':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MunicipioPrestacao')
            self.MunicipioPrestacao = ival_
            # validate type tpCodCidade
            self.validate_tpCodCidade(self.MunicipioPrestacao)
        elif nodeName_ == 'MunicipioPrestacaoDescricao':
            MunicipioPrestacaoDescricao_ = child_.text
            MunicipioPrestacaoDescricao_ = self.gds_validate_string(MunicipioPrestacaoDescricao_, node, 'MunicipioPrestacaoDescricao')
            self.MunicipioPrestacaoDescricao = MunicipioPrestacaoDescricao_
            # validate type tpCidadeDescricao
            self.validate_tpCidadeDescricao(self.MunicipioPrestacaoDescricao)
        elif nodeName_ == 'Operacao':
            Operacao_ = child_.text
            Operacao_ = self.gds_validate_string(Operacao_, node, 'Operacao')
            self.Operacao = Operacao_
            # validate type tpOperacao
            self.validate_tpOperacao(self.Operacao)
        elif nodeName_ == 'Tributacao':
            Tributacao_ = child_.text
            Tributacao_ = self.gds_validate_string(Tributacao_, node, 'Tributacao')
            self.Tributacao = Tributacao_
            # validate type tpTributacao
            self.validate_tpTributacao(self.Tributacao)
        elif nodeName_ == 'ValorPIS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorPIS')
            self.ValorPIS = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorPIS)
        elif nodeName_ == 'ValorCOFINS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorCOFINS')
            self.ValorCOFINS = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorCOFINS)
        elif nodeName_ == 'ValorINSS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorINSS')
            self.ValorINSS = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorINSS)
        elif nodeName_ == 'ValorIR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorIR')
            self.ValorIR = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorIR)
        elif nodeName_ == 'ValorCSLL':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorCSLL')
            self.ValorCSLL = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorCSLL)
        elif nodeName_ == 'AliquotaPIS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaPIS')
            self.AliquotaPIS = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaPIS)
        elif nodeName_ == 'AliquotaCOFINS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaCOFINS')
            self.AliquotaCOFINS = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaCOFINS)
        elif nodeName_ == 'AliquotaINSS':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaINSS')
            self.AliquotaINSS = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaINSS)
        elif nodeName_ == 'AliquotaIR':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaIR')
            self.AliquotaIR = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaIR)
        elif nodeName_ == 'AliquotaCSLL':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaCSLL')
            self.AliquotaCSLL = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaCSLL)
        elif nodeName_ == 'DescricaoRPS':
            DescricaoRPS_ = child_.text
            DescricaoRPS_ = self.gds_validate_string(DescricaoRPS_, node, 'DescricaoRPS')
            self.DescricaoRPS = DescricaoRPS_
            # validate type tpDescricaoRPS
            self.validate_tpDescricaoRPS(self.DescricaoRPS)
        elif nodeName_ == 'DDDPrestador':
            DDDPrestador_ = child_.text
            DDDPrestador_ = self.gds_validate_string(DDDPrestador_, node, 'DDDPrestador')
            self.DDDPrestador = DDDPrestador_
            # validate type tpDDDNulo
            self.validate_tpDDDNulo(self.DDDPrestador)
        elif nodeName_ == 'TelefonePrestador':
            TelefonePrestador_ = child_.text
            TelefonePrestador_ = self.gds_validate_string(TelefonePrestador_, node, 'TelefonePrestador')
            self.TelefonePrestador = TelefonePrestador_
            # validate type tpFoneNulo
            self.validate_tpFoneNulo(self.TelefonePrestador)
        elif nodeName_ == 'DDDTomador':
            DDDTomador_ = child_.text
            DDDTomador_ = self.gds_validate_string(DDDTomador_, node, 'DDDTomador')
            self.DDDTomador = DDDTomador_
            # validate type tpDDDNulo
            self.validate_tpDDDNulo(self.DDDTomador)
        elif nodeName_ == 'TelefoneTomador':
            TelefoneTomador_ = child_.text
            TelefoneTomador_ = self.gds_validate_string(TelefoneTomador_, node, 'TelefoneTomador')
            self.TelefoneTomador = TelefoneTomador_
            # validate type tpFoneNulo
            self.validate_tpFoneNulo(self.TelefoneTomador)
        elif nodeName_ == 'MotCancelamento':
            MotCancelamento_ = child_.text
            MotCancelamento_ = self.gds_validate_string(MotCancelamento_, node, 'MotCancelamento')
            self.MotCancelamento = MotCancelamento_
            # validate type tpMotCancelamento
            self.validate_tpMotCancelamento(self.MotCancelamento)
        elif nodeName_ == 'CPFCNPJIntermediario':
            CPFCNPJIntermediario_ = child_.text
            CPFCNPJIntermediario_ = self.gds_validate_string(CPFCNPJIntermediario_, node, 'CPFCNPJIntermediario')
            self.CPFCNPJIntermediario = CPFCNPJIntermediario_
            # validate type tpCPFCNPJnulo
            self.validate_tpCPFCNPJnulo(self.CPFCNPJIntermediario)
        elif nodeName_ == 'Deducoes':
            obj_ = tpListaDeducoes.factory()
            obj_.build(child_)
            self.Deducoes = obj_
            obj_.original_tagname_ = 'Deducoes'
        elif nodeName_ == 'Itens':
            obj_ = tpListaItens.factory()
            obj_.build(child_)
            self.Itens = obj_
            obj_.original_tagname_ = 'Itens'
# end class tpRPS


class SignatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.SignedInfo = SignedInfo
        self.SignatureValue = SignatureValue
        self.KeyInfo = KeyInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='SignatureType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='SignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='SignatureType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            self.SignedInfo.export(outfile, level, namespace_, name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            self.SignatureValue.export(outfile, level, namespace_, name_='SignatureValue', pretty_print=pretty_print)
        if self.KeyInfo is not None:
            self.KeyInfo.export(outfile, level, namespace_, name_='KeyInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory()
            obj_.build(child_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory()
            obj_.build(child_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory()
            obj_.build(child_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='SignatureValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='SignatureValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='SignatureValueType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='SignatureValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.CanonicalizationMethod = CanonicalizationMethod
        self.SignatureMethod = SignatureMethod
        self.Reference = Reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='SignedInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignedInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='SignedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='SignedInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            self.CanonicalizationMethod.export(outfile, level, namespace_, name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            self.SignatureMethod.export(outfile, level, namespace_, name_='SignatureMethod', pretty_print=pretty_print)
        if self.Reference is not None:
            self.Reference.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory()
            obj_.build(child_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory()
            obj_.build(child_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference = obj_
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class ReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, URI=None, Type=None, Transforms=None, DigestMethod=None, DigestValue=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.URI = _cast(None, URI)
        self.Type = _cast(None, Type)
        self.Transforms = Transforms
        self.DigestMethod = DigestMethod
        self.DigestValue = DigestValue
        self.validate_DigestValueType(self.DigestValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DigestValueType(self, value):
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='ReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='ReferenceType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(outfile, level, namespace_, name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            self.DigestMethod.export(outfile, level, namespace_, name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:DigestValue>%s</ns1:DigestValue>%s' % (self.gds_format_base64(self.DigestValue, input_name='DigestValue'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory()
            obj_.build(child_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'DigestValue')
            else:
                bval_ = None
            self.DigestValue = bval_
            # validate type DigestValueType
            self.validate_DigestValueType(self.DigestValue)
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Transform=None):
        self.original_tagname_ = None
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='TransformsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='TransformsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='TransformsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            Transform_.export(outfile, level, namespace_, name_='Transform', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory()
            obj_.build(child_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, XPath=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.XPath
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='TransformType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='TransformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='TransformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XPath_ in self.XPath:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:XPath>%s</ns1:XPath>%s' % (self.gds_encode(self.gds_format_string(quote_xml(XPath_), input_name='XPath')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XPath':
            XPath_ = child_.text
            XPath_ = self.gds_validate_string(XPath_, node, 'XPath')
            self.XPath.append(XPath_)
# end class TransformType


class KeyInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, X509Data=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.X509Data = X509Data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.X509Data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='KeyInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='KeyInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='KeyInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Data is not None:
            self.X509Data.export(outfile, level, namespace_, name_='X509Data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Data':
            obj_ = X509DataType.factory()
            obj_.build(child_)
            self.X509Data = obj_
            obj_.original_tagname_ = 'X509Data'
# end class KeyInfoType


class X509DataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X509Certificate=None):
        self.original_tagname_ = None
        self.X509Certificate = X509Certificate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.X509Certificate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='X509DataType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='X509DataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='X509DataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='X509DataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Certificate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns1:X509Certificate>%s</ns1:X509Certificate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.X509Certificate), input_name='X509Certificate')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Certificate':
            X509Certificate_ = child_.text
            X509Certificate_ = self.gds_validate_string(X509Certificate_, node, 'X509Certificate')
            self.X509Certificate = X509Certificate_
# end class X509DataType


class CanonicalizationMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='CanonicalizationMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanonicalizationMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CanonicalizationMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='CanonicalizationMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='CanonicalizationMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='SignatureMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='SignatureMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='SignatureMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureMethodType


class DigestMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns1:', name_='DigestMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DigestMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns1:', name_='DigestMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns1:', name_='DigestMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='ns1:', name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DigestMethodType


GDSClassesMapping = {
    'Signature': SignatureType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReqConsultaNFSeRPS'
        rootClass = ReqConsultaNFSeRPS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ns1="http://localhost:8080/WsNFe2/lote"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReqConsultaNFSeRPS'
        rootClass = ReqConsultaNFSeRPS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReqConsultaNFSeRPS'
        rootClass = ReqConsultaNFSeRPS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ns1="http://localhost:8080/WsNFe2/lote"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReqConsultaNFSeRPS'
        rootClass = ReqConsultaNFSeRPS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ReqConsultaNFSeRPS import *\n\n')
        sys.stdout.write('import ReqConsultaNFSeRPS as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CabecalhoType",
    "CanonicalizationMethodType",
    "DigestMethodType",
    "KeyInfoType",
    "ReferenceType",
    "ReqConsultaNFSeRPS",
    "SignatureMethodType",
    "SignatureType",
    "SignatureValueType",
    "SignedInfoType",
    "TransformType",
    "TransformsType",
    "X509DataType",
    "tpBairroCompleto",
    "tpCPFCNPJ2",
    "tpChaveNFe",
    "tpChaveNFeRPS",
    "tpChaveRPS",
    "tpChaveSubstituicaoNFSe",
    "tpConsultaNFSe",
    "tpDeducoes",
    "tpDetalhesConsultaRPS",
    "tpEndereco",
    "tpEvento",
    "tpInformacoesLote",
    "tpItens",
    "tpListaAlertas",
    "tpListaDeducoes",
    "tpListaDetalhesConsultaRPS",
    "tpListaErros",
    "tpListaItens",
    "tpListaNFSe",
    "tpListaNFSeConsultaNota",
    "tpListaNFSeRPS",
    "tpLogradouroCompleto",
    "tpLote",
    "tpLoteCancelamentoNFSe",
    "tpLoteConsultaNFSe",
    "tpNFSe",
    "tpNotaCancelamentoNFSe",
    "tpNotaConsultaNFSe",
    "tpNotasCancelamentoNFSe",
    "tpNotasConsultaNFSe",
    "tpRPS",
    "tpRPSConsultaNFSe",
    "tpRPSsConsultaNFSe",
    "tpRetornoNotasCancelamentoNFSe"
]
